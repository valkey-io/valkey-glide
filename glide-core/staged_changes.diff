diff --git a/glide-core/redis-rs/redis/src/client.rs b/glide-core/redis-rs/redis/src/client.rs
index e9fb97635..0ca1f2a6b 100644
--- a/glide-core/redis-rs/redis/src/client.rs
+++ b/glide-core/redis-rs/redis/src/client.rs
@@ -569,6 +569,11 @@ impl Client {
     pub fn update_password(&mut self, password: Option<String>) {
         self.connection_info.redis.password = password;
     }
+
+    /// Updates the client_name in connection_info.
+    pub fn update_client_name(&mut self, client_name: Option<String>) {
+        self.connection_info.redis.client_name = client_name;
+    }
 }
 
 #[cfg(feature = "aio")]
diff --git a/glide-core/redis-rs/redis/src/cluster_async/mod.rs b/glide-core/redis-rs/redis/src/cluster_async/mod.rs
index 70e92ae4a..34103d03e 100644
--- a/glide-core/redis-rs/redis/src/cluster_async/mod.rs
+++ b/glide-core/redis-rs/redis/src/cluster_async/mod.rs
@@ -332,6 +332,15 @@ where
             .await
     }
 
+    /// Update the name used for all cluster connections
+    pub async fn update_connection_client_name(
+        &mut self,
+        client_name: Option<String>,
+    ) -> RedisResult<Value> {
+        self.route_operation_request(Operation::UpdateConnectionClientName(client_name))
+            .await
+    }
+
     /// Get the username used to authenticate with all cluster servers
     pub async fn get_username(&mut self) -> RedisResult<Value> {
         self.route_operation_request(Operation::GetUsername).await
@@ -655,6 +664,7 @@ enum CmdArg<C> {
 #[derive(Clone)]
 enum Operation {
     UpdateConnectionPassword(Option<String>),
+    UpdateConnectionClientName(Option<String>),
     GetUsername,
 }
 
@@ -2592,6 +2602,11 @@ where
                         .expect(MUTEX_WRITE_ERR);
                     Ok(Response::Single(Value::Okay))
                 }
+                Operation::UpdateConnectionClientName(client_name) => {
+                    core.set_cluster_param(|params| params.client_name = client_name)
+                        .expect(MUTEX_WRITE_ERR);
+                    Ok(Response::Single(Value::Okay))
+                }
                 Operation::GetUsername => {
                     let username = match core
                         .get_cluster_param(|params| params.username.clone())
diff --git a/glide-core/src/client/mod.rs b/glide-core/src/client/mod.rs
index 226bab03d..05381918f 100644
--- a/glide-core/src/client/mod.rs
+++ b/glide-core/src/client/mod.rs
@@ -330,6 +330,62 @@ fn get_request_timeout(cmd: &Cmd, default_timeout: Duration) -> RedisResult<Opti
 }
 
 impl Client {
+    /// Checks if the given command is a CLIENT SETNAME command.
+    /// Returns true if the command is "CLIENT SETNAME", false otherwise.
+    fn is_client_set_name_command(&self, cmd: &Cmd) -> bool {
+        // Check if the command is "CLIENT SETNAME"
+        cmd.command()
+            .is_some_and(|bytes| bytes == b"CLIENT SETNAME")
+    }
+
+    /// Extracts the client name from a CLIENT SETNAME command.
+    /// Parses the client name argument from the CLIENT SETNAME command.
+    /// Returns None if the argument is missing or invalid.
+    fn extract_client_name_from_client_set_name(&self, cmd: &Cmd) -> Option<String> {
+        // For redis::cmd("CLIENT").arg("SETNAME").arg("name")
+        // the client name is at arg_idx(2) (after "SETNAME")
+        cmd.arg_idx(2).and_then(|name_bytes| {
+            std::str::from_utf8(name_bytes)
+                .ok()
+                .map(|name_str| name_str.to_string())
+        })
+    }
+
+    /// Handles CLIENT SETNAME command processing after successful execution.
+    /// Updates connection name state for standalone, cluster, and lazy clients.
+    async fn handle_client_set_name_command(
+        &mut self,
+        cmd: &Cmd,
+        value: Value,
+    ) -> RedisResult<Value> {
+        // Extract client name from the CLIENT SETNAME command
+        let client_name = self.extract_client_name_from_client_set_name(cmd);
+
+        // Update client name state for all client types
+        self.update_stored_client_name(client_name).await?;
+        Ok(value)
+    }
+
+    /// Updates the stored client name for different client types.
+    /// Handles standalone, cluster, and lazy clients appropriately.
+    /// Ensures thread-safe updates using existing synchronization mechanisms.
+    async fn update_stored_client_name(&self, client_name: Option<String>) -> RedisResult<()> {
+        let mut guard = self.internal_client.write().await;
+        match &mut *guard {
+            ClientWrapper::Standalone(client) => {
+                client.update_connection_client_name(client_name).await?;
+                Ok(())
+            }
+            ClientWrapper::Cluster { client } => {
+                // Update cluster connection database configuration
+                client.update_connection_client_name(client_name).await?;
+                Ok(())
+            }
+            ClientWrapper::Lazy(_) => {
+                unreachable!("Lazy client should have been initialized")
+            }
+        }
+    }
     async fn get_or_initialize_client(&self) -> RedisResult<ClientWrapper> {
         {
             let guard = self.internal_client.read().await;
@@ -427,6 +483,12 @@ impl Client {
             })
             .await?;
 
+            // Intercept CLIENT SETNAME commands after regular processing
+            // Only handle CLIENT SETNAME commands if they executed successfully (no error)
+            if self.is_client_set_name_command(cmd) {
+                return self.handle_client_set_name_command(cmd, value).await;
+            }
+
             Ok(value)
         })
     }
@@ -1194,13 +1256,14 @@ impl GlideClientForTests for StandaloneClient {
 mod tests {
     use std::time::Duration;
 
+    use crate::client::types::{ConnectionRequest, NodeAddress};
     use redis::Cmd;
 
     use crate::client::{
         BLOCKING_CMD_TIMEOUT_EXTENSION, RequestTimeoutOption, TimeUnit, get_request_timeout,
     };
 
-    use super::get_timeout_from_cmd_arg;
+    use super::{Client, ClientWrapper, LazyClient, get_timeout_from_cmd_arg};
 
     #[test]
     fn test_get_timeout_from_cmd_returns_correct_duration_int() {
@@ -1349,4 +1412,83 @@ mod tests {
         assert!(result.is_ok());
         assert_eq!(result.unwrap(), Some(Duration::from_millis(100)));
     }
+
+    #[test]
+    fn test_is_client_set_name_command() {
+        // Create a mock client for testing
+        let client = create_test_client();
+
+        // Test valid CLIENT SETNAME command
+        let mut cmd = Cmd::new();
+        cmd.arg("CLIENT").arg("SETNAME").arg("test_client");
+        assert!(client.is_client_set_name_command(&cmd));
+
+        // Test CLIENT SETNAME with different case (should work due to case-insensitive comparison)
+        let mut cmd = Cmd::new();
+        cmd.arg("client").arg("setname").arg("test_client");
+        assert!(client.is_client_set_name_command(&cmd));
+
+        // Test CLIENT command without SETNAME
+        let mut cmd = Cmd::new();
+        cmd.arg("CLIENT").arg("INFO");
+        assert!(!client.is_client_set_name_command(&cmd));
+
+        // Test non-CLIENT command
+        let mut cmd = Cmd::new();
+        cmd.arg("SET").arg("key").arg("value");
+        assert!(!client.is_client_set_name_command(&cmd));
+
+        // Test CLIENT SETNAME without client name argument
+        let mut cmd = Cmd::new();
+        cmd.arg("CLIENT").arg("SETNAME");
+        assert!(client.is_client_set_name_command(&cmd));
+
+        // Test CLIENT only
+        let mut cmd = Cmd::new();
+        cmd.arg("CLIENT");
+        assert!(!client.is_client_set_name_command(&cmd));
+    }
+
+    #[test]
+    fn test_extract_client_name_from_client_set_name() {
+        // Test detection of valid CLIENT SETNAME commands
+        let client = create_test_client();
+
+        // Test uppercase CLIENT SETNAME command
+        let mut cmd = Cmd::new();
+        cmd.arg("CLIENT").arg("SETNAME").arg("test_name");
+        assert_eq!(
+            client.extract_client_name_from_client_set_name(&cmd),
+            Some("test_name".to_string())
+        );
+    }
+
+    /// Helper function to create a test client for unit tests
+    fn create_test_client() -> Client {
+        use std::sync::Arc;
+        use std::sync::atomic::AtomicIsize;
+        use tokio::sync::RwLock;
+
+        let config = ConnectionRequest {
+            database_id: 0,
+            cluster_mode_enabled: false,
+            addresses: vec![NodeAddress {
+                host: "127.0.0.1".to_string(),
+                port: 6379,
+            }],
+            lazy_connect: true,
+            ..Default::default()
+        };
+
+        let lazy_client = LazyClient {
+            config,
+            push_sender: None,
+        };
+
+        Client {
+            internal_client: Arc::new(RwLock::new(ClientWrapper::Lazy(Box::new(lazy_client)))),
+            request_timeout: Duration::from_millis(250),
+            inflight_requests_allowed: Arc::new(AtomicIsize::new(1000)),
+        }
+    }
 }
diff --git a/glide-core/src/client/reconnecting_connection.rs b/glide-core/src/client/reconnecting_connection.rs
index 6fa4a464c..7045227f9 100644
--- a/glide-core/src/client/reconnecting_connection.rs
+++ b/glide-core/src/client/reconnecting_connection.rs
@@ -394,6 +394,17 @@ impl ReconnectingConnection {
         client.update_password(new_password);
     }
 
+    /// Updates the client name that's saved inside connection_info, that will be used in case of disconnection from the server.
+    pub(crate) fn update_connection_client_name(&self, new_client_name: Option<String>) {
+        let mut client = self
+            .inner
+            .backend
+            .connection_info
+            .write()
+            .expect(WRITE_LOCK_ERR);
+        client.update_client_name(new_client_name);
+    }
+
     /// Returns the username if one was configured during client creation. Otherwise, returns None.
     pub(crate) fn get_username(&self) -> Option<String> {
         let client = self.inner.backend.get_backend_client();
diff --git a/glide-core/src/client/standalone_client.rs b/glide-core/src/client/standalone_client.rs
index 22f33a3b9..e0d56aea5 100644
--- a/glide-core/src/client/standalone_client.rs
+++ b/glide-core/src/client/standalone_client.rs
@@ -623,6 +623,18 @@ impl StandaloneClient {
         Ok(Value::Okay)
     }
 
+    /// Update the client_name used to create the connection.
+    pub async fn update_connection_client_name(
+        &self,
+        new_client_name: Option<String>,
+    ) -> RedisResult<Value> {
+        for node in self.inner.nodes.iter() {
+            node.update_connection_client_name(new_client_name.clone());
+        }
+
+        Ok(Value::Okay)
+    }
+
     /// Retrieve the username used to authenticate with the server.
     pub fn get_username(&self) -> Option<String> {
         // All nodes in the client should have the same username configured, thus any connection would work here.
diff --git a/glide-core/tests/test_client.rs b/glide-core/tests/test_client.rs
index afd54f9c8..cbdc68675 100644
--- a/glide-core/tests/test_client.rs
+++ b/glide-core/tests/test_client.rs
@@ -1530,4 +1530,154 @@ pub(crate) mod shared_client_tests {
             );
         });
     }
+
+    #[rstest]
+    #[serial_test::serial]
+    #[timeout(SHORT_CLUSTER_TEST_TIMEOUT)]
+    /// Test that verifies the client maintains the correct client name after an automatic reconnection
+    /// when the client name was changed using the CLIENT SETNAME command.
+    /// This test:
+    /// 1. Creates a client with a name "1stName"
+    /// 2. Uses CLIENT SETNAME command to change to "2ndName"
+    /// 3. Verifies the connection is now with the "2ndName"
+    /// 4. Simulates a connection drop by killing the connection
+    /// 5. Sends another command which either:
+    ///    - Fails due to the dropped connection, then retries and verifies reconnection has the name "2ndName" set
+    ///    - Succeeds with a new client ID (indicating reconnection) and verifies still has the name "2ndName" set
+    /// This ensures that client name via CLIENT SETNAME command persists across reconnections.
+    fn test_client_set_name_command_database_persistence_after_reconnection(
+        #[values(false, true)] use_cluster: bool,
+    ) {
+        block_on_all(async move {
+            if use_cluster {
+                // First create a basic client to check server version
+                let mut version_check_basics = setup_test_basics(
+                    use_cluster,
+                    TestConfiguration {
+                        shared_server: true,
+                        ..Default::default()
+                    },
+                )
+                .await;
+
+                // Skip test if server version is less than 9.0 (database isolation not supported in cluster)
+                if !utilities::version_greater_or_equal(&mut version_check_basics.client, "9.0.0")
+                    .await
+                {
+                    return;
+                }
+            }
+
+            let mut test_basics = setup_test_basics(
+                use_cluster,
+                TestConfiguration {
+                    client_name: Some("1stName".to_string()), // Start with default database
+                    shared_server: true,
+                    ..Default::default()
+                },
+            )
+            .await;
+
+            let mut client_info_cmd = redis::Cmd::new();
+            client_info_cmd.arg("CLIENT").arg("INFO");
+
+            let mut select_cmd = redis::Cmd::new();
+            select_cmd.arg("Client").arg("SETNAME").arg("2ndName");
+
+            // Verify initial connection is to database 0
+            let initial_client_info_response = test_basics
+                .client
+                .send_command(&client_info_cmd, None)
+                .await
+                .unwrap();
+
+            let initial_client_info = match initial_client_info_response {
+                Value::BulkString(bytes) => String::from_utf8_lossy(&bytes).to_string(),
+                Value::VerbatimString { text, .. } => text,
+                _ => panic!(
+                    "Unexpected CLIENT INFO response type: {:?}",
+                    initial_client_info_response
+                ),
+            };
+            assert!(initial_client_info.contains("name=1stName"));
+
+            // Extract initial client ID
+            let initial_client_id = utilities::extract_client_id(&initial_client_info)
+                .expect("Failed to extract initial client ID");
+
+            // Execute CLIENT SETNAME command to change to 2ndName
+            let select_result = test_basics
+                .client
+                .send_command(&select_cmd, None)
+                .await
+                .unwrap();
+            assert_eq!(select_result, Value::Okay);
+
+            // Verify we're now on database 5
+            let post_select_client_info_response = test_basics
+                .client
+                .send_command(&client_info_cmd, None)
+                .await
+                .unwrap();
+
+            let post_select_client_info = match post_select_client_info_response {
+                Value::BulkString(bytes) => String::from_utf8_lossy(&bytes).to_string(),
+                Value::VerbatimString { text, .. } => text,
+                _ => panic!(
+                    "Unexpected CLIENT INFO response type: {:?}",
+                    post_select_client_info_response
+                ),
+            };
+            assert!(post_select_client_info.contains("name=2ndName"));
+
+            // Kill the connection to simulate a network drop
+            kill_connection(&mut test_basics.client).await;
+
+            // Try to send another command - this should trigger reconnection
+            let res = test_basics
+                .client
+                .send_command(&client_info_cmd, None)
+                .await;
+            match res {
+                Err(err) => {
+                    // Connection was dropped as expected
+                    assert!(
+                        err.is_connection_dropped() || err.is_timeout(),
+                        "Expected connection dropped or timeout error, got: {err:?}",
+                    );
+                    // Retry and verify we're still on name 2ndName after reconnection
+                    let client_info = repeat_try_create(|| async {
+                        let mut client = test_basics.client.clone();
+                        let response = client.send_command(&client_info_cmd, None).await.ok()?;
+                        match response {
+                            Value::BulkString(bytes) => {
+                                Some(String::from_utf8_lossy(&bytes).to_string())
+                            }
+                            Value::VerbatimString { text, .. } => Some(text),
+                            _ => None,
+                        }
+                    })
+                    .await;
+                    assert!(client_info.contains("name=2ndName"));
+                }
+                Ok(response) => {
+                    // Command succeeded, extract new client ID and compare
+                    let new_client_info = match response {
+                        Value::BulkString(bytes) => String::from_utf8_lossy(&bytes).to_string(),
+                        Value::VerbatimString { text, .. } => text,
+                        _ => panic!("Unexpected CLIENT INFO response type: {:?}", response),
+                    };
+                    let new_client_id = utilities::extract_client_id(&new_client_info)
+                        .expect("Failed to extract new client ID");
+                    assert_ne!(
+                        initial_client_id, new_client_id,
+                        "Client ID should change after reconnection if command succeeds"
+                    );
+                    // Check that the client name is still 2ndName (from CLIENT SETNAME command)
+                    println!("{}", new_client_info);
+                    assert!(new_client_info.contains("name=2ndName"));
+                }
+            }
+        });
+    }
 }
