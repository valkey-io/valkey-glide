plugins {
    id 'java-library'
}

repositories {
    mavenCentral()
}

dependencies {
    // client
    implementation project(':client')

    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.13.0'

    // https://github.com/netty/netty/wiki/Native-transports
    // At the moment, Windows is not supported
    implementation group: 'io.netty', name: 'netty-transport-native-epoll', version: '4.1.100.Final', classifier: 'linux-x86_64'
    implementation group: 'io.netty', name: 'netty-transport-native-kqueue', version: '4.1.100.Final', classifier: 'osx-x86_64'
    implementation group: 'io.netty', name: 'netty-transport-native-kqueue', version: '4.1.100.Final', classifier: 'osx-aarch_64'

    // junit
    testImplementation 'org.mockito:mockito-junit-jupiter:3.12.4'
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter', version: '5.10.2'

    // semver4j for semantic versioning
    implementation 'com.vdurmont:semver4j:3.1.0'

    //lombok
    testCompileOnly 'org.projectlombok:lombok:1.18.32'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.32'
}

def standalonePorts = []
def clusterPorts = []
def serverVersion = ""

ext {
    extractPortsFromClusterManagerOutput = { String output ->
        var res = []
        for (def line : output.split("\n")) {
            if (!line.startsWith("CLUSTER_NODES="))
                continue

            def addresses = line.split("=")[1].split(",")
            for (def address : addresses)
                res << address.split(":")[1]
        }
        return res
    }
    extractServerVersion = { String output ->
        // Redis response:
        // Redis server v=7.2.3 sha=00000000:0 malloc=jemalloc-5.3.0 bits=64 build=7504b1fedf883f2
        // Valkey response:
        // Server v=7.2.5 sha=26388270:0 malloc=jemalloc-5.3.0 bits=64 build=ea40bb1576e402d6
        return output.split("v=")[1].split(" ")[0]
    }
}

tasks.register('stopAllAfterTests', Exec) {
    workingDir "${project.rootDir}/../utils"
    commandLine 'python3', 'cluster_manager.py', 'stop', '--prefix', 'redis-cluster', '--keep-folder'
}

// We need to call for stop before and after the test, but gradle doesn't support executing a task
// twice. So there are two identical tasks with different names.
// We need to call for stop in case if previous test run was interrupted/crashed and didn't stop.
tasks.register('stopAllBeforeTests', Exec) {
    workingDir "${project.rootDir}/../utils"
    commandLine 'python3', 'cluster_manager.py', 'stop', '--prefix', 'redis-cluster'
    ignoreExitValue true // ignore fail if servers are stopped before
}

// delete dirs if stop failed due to https://github.com/aws/glide-for-redis/issues/849
tasks.register('clearDirs', Delete) {
    delete "${project.rootDir}/../utils/clusters"
}

tasks.register('startCluster') {
    doLast {
        new ByteArrayOutputStream().withStream { os ->
            exec {
                workingDir "${project.rootDir}/../utils"
                commandLine 'python3', 'cluster_manager.py', 'start', '--cluster-mode'
                standardOutput = os
            }
            clusterPorts = extractPortsFromClusterManagerOutput(os.toString())
        }
    }
}

tasks.register('startStandalone') {
    doLast {
        new ByteArrayOutputStream().withStream { os ->
            exec {
                workingDir "${project.rootDir}/../utils"
                commandLine 'python3', 'cluster_manager.py', 'start', '-r', '0'
                standardOutput = os
            }
            standalonePorts = extractPortsFromClusterManagerOutput(os.toString())
        }
    }
}

tasks.register('getServerVersion') {
    doLast {
        new ByteArrayOutputStream().withStream { os ->
            exec {
                commandLine 'redis-server', '-v'
                standardOutput = os
            }
            serverVersion = extractServerVersion(os.toString())
        }
    }
}

test.dependsOn 'stopAllBeforeTests'
test.dependsOn 'getServerVersion'
stopAllBeforeTests.finalizedBy 'clearDirs'
clearDirs.finalizedBy 'startStandalone'
clearDirs.finalizedBy 'startCluster'
test.finalizedBy 'stopAllAfterTests'
test.dependsOn ':client:buildRustRelease'

tasks.withType(Test) {
    doFirst {
        println "Cluster ports = ${clusterPorts}"
        println "Standalone ports = ${standalonePorts}"
        println "Server version = ${serverVersion}"
        systemProperty 'test.server.standalone.ports', standalonePorts.join(',')
        systemProperty 'test.server.cluster.ports', clusterPorts.join(',')
        systemProperty 'test.server.version', serverVersion
    }

    testLogging {
        exceptionFormat "full"
        events "started", "skipped", "passed", "failed"
        showStandardStreams true
    }

    minHeapSize = "2048m" // Initial heap size. Needed for max size tests.
    maxHeapSize = "2048m" // Maximum heap size. Needed for max size tests.

    afterTest { desc, result ->
        logger.quiet "${desc.className}.${desc.name}: ${result.resultType} ${(result.getEndTime() - result.getStartTime())/1000}s"
    }
}
