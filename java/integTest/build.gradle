plugins {
    id 'java-library'
    id "com.google.osdetector" version "1.7.3"
}

repositories {
    mavenCentral()
    mavenLocal()
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

dependencies {
    def classifier
    if (osdetector.os == 'linux' && osdetector.release.id == 'alpine') {
        classifier = "linux_musl-${osdetector.arch}"
    }
    else {
        classifier = osdetector.classifier
    }
    // Use published GLIDE artifact
    implementation group: 'io.valkey', name: 'valkey-glide', version: project.ext.defaultReleaseVersion, classifier: classifier

    // Use published jedis-compatibility artifact
    testImplementation group: 'io.valkey', name: 'valkey-glide-jedis-compatibility', version: project.ext.defaultReleaseVersion, classifier: osdetector.classifier

    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.18.0'
    implementation 'com.google.code.gson:gson:2.13.2'

    // Add commons-pool2 as compile-time dependency for tests
    implementation group: 'org.apache.commons', name: 'commons-pool2', version: '2.12.1'



    // junit
    testImplementation 'org.mockito:mockito-junit-jupiter:3.12.4'
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter', version: '5.10.2'

    // semver4j for semantic versioning
    implementation group: 'org.semver4j', name: 'semver4j', version: '5.6.0'

    //lombok
    testCompileOnly 'org.projectlombok:lombok:1.18.42'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.42'
}

def standaloneHosts = ''
def standaloneTlsHosts = ''
def clusterHosts = ''
def clusterTlsHosts = ''
def azClusterHosts = ''

// Platform-specific Python executable
def isWindows = System.getProperty('os.name').toLowerCase().contains('windows')
def pythonCmd = isWindows ? ['python3'] : ['python3']

// Use integration test IP from environment variable if available, otherwise default to localhost
def clusterHost = System.getenv('VALKEY_INTEG_TEST_IP') ?: '127.0.0.1'

ext {
    extractAddressesFromClusterManagerOutput = { String output ->
        for (def line : output.readLines()) {  // Use readLines() for cross-platform line splitting
            if (!line.startsWith("CLUSTER_NODES="))
                continue

            return line.split("=")[1].trim()  // Add trim() to remove trailing whitespace
        }
        return ''
    }
}

tasks.register('stopAllAfterTests') {
    doLast {
        // Check if we should use remote cluster manager
        def remoteHost = System.getenv("VALKEY_REMOTE_HOST")
        if (remoteHost != null && !remoteHost.isEmpty()) {
            // Stop remote clusters
            exec {
                workingDir "${project.rootDir}/../utils"
                commandLine(*pythonCmd, 'remote_cluster_manager.py', '--host', remoteHost, 'stop')
                ignoreExitValue true // ignore fail if servers are stopped before
            }
        } else {
            // Stop local clusters
            exec {
                workingDir "${project.rootDir}/../utils"
                commandLine(*pythonCmd, 'cluster_manager.py', '--host', clusterHost, 'stop', '--prefix', 'cluster', '--keep-folder')
                ignoreExitValue true // ignore fail if servers are stopped before
            }
            exec {
                workingDir "${project.rootDir}/../utils"
                commandLine(*pythonCmd, 'cluster_manager.py', '--host', clusterHost, 'stop', '--prefix', 'cluster', '--keep-folder')
                ignoreExitValue true
            }
        }
    }
}

// We need to call for stop before and after the test, but gradle doesn't support executing a task
// twice. So there are two identical tasks with different names.
// We need to call for stop in case if previous test run was interrupted/crashed and didn't stop.
tasks.register('stopAllBeforeTests') {
    doLast {
        println "=== STOPPING ALL CLUSTERS BEFORE TESTS ==="
        // Check if we should use remote cluster manager
        def remoteHost = System.getenv("VALKEY_REMOTE_HOST")
        if (remoteHost != null && !remoteHost.isEmpty()) {
            println "Stopping remote clusters on: ${remoteHost}"
            // Stop remote clusters
            exec {
                workingDir "${project.rootDir}/../utils"
                commandLine(*pythonCmd, 'remote_cluster_manager.py', '--host', remoteHost, 'stop')
                ignoreExitValue true // ignore fail if servers are stopped before
            }
        } else {
            // Stop local clusters
            exec {
                workingDir "${project.rootDir}/../utils"
                commandLine(*pythonCmd, 'cluster_manager.py', '--host', clusterHost, 'stop', '--prefix', 'cluster', '--keep-folder')
                ignoreExitValue true // ignore fail if servers are stopped before
            }
            exec {
                workingDir "${project.rootDir}/../utils"
                commandLine(*pythonCmd, 'cluster_manager.py', '--host', clusterHost, 'stop', '--prefix', 'cluster', '--keep-folder')
                ignoreExitValue true
            }
        }
    }
}

// delete dirs if stop failed due to https://github.com/valkey-io/valkey-glide/issues/849
tasks.register('clearDirs', Delete) {
    delete "${project.rootDir}/../utils/clusters"
}

tasks.register('startCluster') {
    doLast {
        if (System.getProperty("cluster-endpoints") == null) {
            def engineVersion = System.getProperty("engine-version") ?: "valkey-8.0"
            // Check if we should use remote cluster manager
            def remoteHost = System.getenv("VALKEY_REMOTE_HOST")
            if (remoteHost != null && !remoteHost.isEmpty()) {
                // Use remote cluster manager
                println "Using remote cluster manager for standalone with host: ${remoteHost}"
                new ByteArrayOutputStream().withStream { os ->
                    exec {
                        workingDir "${project.rootDir}/../utils"
                        def args = [*pythonCmd, 'remote_cluster_manager.py', '--host', remoteHost]
                        if (System.getProperty("engine-version")) args.addAll(['--engine-version', System.getProperty("engine-version")])
                        args.addAll(['start', '--cluster-mode', '-r', '1'])
                        if (System.getProperty("tls") == 'true') args.add('--tls')
                        commandLine args
                        standardOutput = os
                    }
                    // Parse remote cluster endpoints
                    clusterHosts = extractAddressesFromClusterManagerOutput(os.toString())
                }
            } else {
                // Use local cluster manager (original behavior for non-Windows)
                new ByteArrayOutputStream().withStream { os ->
                    exec {
                        workingDir "${project.rootDir}/../utils"
                        def args = [*pythonCmd, 'cluster_manager.py', '--host', clusterHost, 'start', '--cluster-mode', '-r', '1']
                        if (System.getProperty("tls") == 'true') args.add('--tls')
                        commandLine args
                        standardOutput = os
                    }
                    clusterHosts = extractAddressesFromClusterManagerOutput(os.toString())
                }
            }
        } else {
            clusterHosts = System.getProperty("cluster-endpoints")
        }
    }
}

tasks.register('startClusterForAz') {
    doLast {
        if (System.getProperty("cluster-endpoints") == null) {
            def engineVersion = System.getProperty("engine-version") ?: "valkey-8.0"

            // Check if we should use remote cluster manager
            def remoteHost = System.getenv("VALKEY_REMOTE_HOST")
            if (remoteHost != null && !remoteHost.isEmpty()) {
                // Use remote cluster manager
                new ByteArrayOutputStream().withStream { os ->
                    exec {
                        workingDir "${project.rootDir}/../utils"
                        def args = [*pythonCmd, 'remote_cluster_manager.py', '--host', remoteHost]
                        if (System.getProperty("engine-version")) args.addAll(['--engine-version', System.getProperty("engine-version")])
                        args.addAll(['start', '--cluster-mode', '-r', '4'])
                        if (System.getProperty("tls") == 'true') args.add('--tls')
                        commandLine args
                        standardOutput = os
                    }
                    // Parse remote cluster endpoints
                    azClusterHosts = extractAddressesFromClusterManagerOutput(os.toString())
                }
            } else {
                // Use local cluster manager (original behavior for non-Windows)
                new ByteArrayOutputStream().withStream { os ->
                    exec {
                        workingDir "${project.rootDir}/../utils"
                        def args = [*pythonCmd, 'cluster_manager.py', '--host', clusterHost, 'start', '--cluster-mode', '-r', '4']
                        if (System.getProperty("tls") == 'true') args.add('--tls')
                        commandLine args
                        standardOutput = os
                    }
                    azClusterHosts = extractAddressesFromClusterManagerOutput(os.toString())
                }
            }
        } else {
            azClusterHosts = System.getProperty("cluster-endpoints")
        }
    }
}

tasks.register('beforeTests') {}
tasks.register('afterTests') {}
tasks.register('startStandalone') {
    doLast {
        if (System.getProperty("standalone-endpoints") == null) {
            new ByteArrayOutputStream().withStream { os ->
                exec {
                    workingDir "${project.rootDir}/../utils"

                    // Check if we should use remote cluster manager
                    def remoteHost = System.getenv("VALKEY_REMOTE_HOST")
                    if (remoteHost != null && !remoteHost.isEmpty()) {
                        def args = [*pythonCmd, 'remote_cluster_manager.py', '--host', remoteHost]
                        if (System.getProperty("engine-version")) args.addAll(['--engine-version', System.getProperty("engine-version")])
                        args.addAll(['start', '-r', '0'])
                        if (System.getProperty("tls") == 'true') args.add('--tls')
                        commandLine args
                    } else {
                        def args = [*pythonCmd, 'cluster_manager.py', '--host', clusterHost, 'start', '-r', '0']
                        if (System.getProperty("tls") == 'true') args.add('--tls')
                        commandLine args
                    }
                    standardOutput = os
                }
                standaloneHosts = extractAddressesFromClusterManagerOutput(os.toString())
            }
        } else {
            standaloneHosts = System.getProperty("standalone-endpoints")
        }
    }
}

tasks.register('startStandaloneTls') {
    doLast {
        if (System.getProperty("standalone-tls-endpoints") == null) {
            new ByteArrayOutputStream().withStream { os ->
                exec {
                    workingDir "${project.rootDir}/../utils"
                    
                    // Check if we should use remote cluster manager
                    def remoteHost = System.getenv("VALKEY_REMOTE_HOST")
                    if (remoteHost != null && !remoteHost.isEmpty()) {
                        def args = [*pythonCmd, 'remote_cluster_manager.py', '--host', remoteHost]
                        if (System.getProperty("engine-version")) args.addAll(['--engine-version', System.getProperty("engine-version")])
                        args.addAll(['start', '--tls', '-r', '0'])
                        commandLine args
                    } else {
                        commandLine 'python3', 'cluster_manager.py', 'start', '--tls', '-r', '0'
                    }
                    standardOutput = os
                }
                standaloneTlsHosts = extractAddressesFromClusterManagerOutput(os.toString())
            }
        } else {
            standaloneTlsHosts = System.getProperty("standalone-tls-endpoints")
        }
    }
}

tasks.register('startClusterTls') {
    doLast {
        if (System.getProperty("cluster-endpoints") == null) {
            // Check if we should use remote cluster manager
            def remoteHost = System.getenv("VALKEY_REMOTE_HOST")
            if (remoteHost != null && !remoteHost.isEmpty()) {
                // Use remote cluster manager
                println "Using remote cluster manager for TLS cluster with host: ${remoteHost}"
                new ByteArrayOutputStream().withStream { os ->
                    exec {
                        workingDir "${project.rootDir}/../utils"
                        def args = [*pythonCmd, 'remote_cluster_manager.py', '--host', remoteHost]
                        if (System.getProperty("engine-version")) args.addAll(['--engine-version', System.getProperty("engine-version")])
                        args.addAll(['start', '--cluster-mode', '--tls', '-n', '2', '-r', '1'])
                        commandLine args
                        standardOutput = os
                    }
                    // Parse remote cluster endpoints
                    clusterTlsHosts = extractAddressesFromClusterManagerOutput(os.toString())
                    println "=== GRADLE CLUSTER TLS SETUP ==="
                    println "Extracted cluster TLS hosts: ${clusterTlsHosts}"
                    println "================================="
                }
            } else {
                // Use local cluster manager
                new ByteArrayOutputStream().withStream { os ->
                    exec {
                        workingDir "${project.rootDir}/../utils"
                        commandLine(*pythonCmd, 'cluster_manager.py', 'start', '--cluster-mode', '--tls', '-n', '2', '-r', '1')
                        standardOutput = os
                    }
                    clusterTlsHosts = extractAddressesFromClusterManagerOutput(os.toString())
                    println "=== GRADLE LOCAL CLUSTER TLS SETUP ==="
                    println "Extracted cluster TLS hosts: ${clusterTlsHosts}"
                    println "======================================="
                }
            }
        } else {
            clusterTlsHosts = System.getProperty("cluster-endpoints")
        }
    }
}

beforeTests.dependsOn 'stopAllBeforeTests'
stopAllBeforeTests.finalizedBy 'clearDirs'
startStandalone.dependsOn 'clearDirs'
startStandaloneTls.dependsOn 'clearDirs'
startCluster.dependsOn 'clearDirs'
startClusterTls.dependsOn 'clearDirs'
startClusterForAz.dependsOn 'clearDirs'
beforeTests.dependsOn 'startStandalone'
beforeTests.dependsOn 'startStandaloneTls'
beforeTests.dependsOn 'startCluster'
beforeTests.dependsOn 'startClusterTls'
beforeTests.dependsOn 'startClusterForAz'
afterTests.finalizedBy 'stopAllAfterTests'
compileTestJava.dependsOn ':client:publishToMavenLocal', ':jedis-compatibility:publishToMavenLocal'

tasks.withType(Test) {
    dependsOn ':client:publishToMavenLocal', ':jedis-compatibility:publishToMavenLocal'
    useJUnitPlatform()
    if (!project.gradle.startParameter.taskNames.contains(':integTest:modulesTest')) {
        dependsOn 'beforeTests'
        finalizedBy 'afterTests'
    }

    doFirst {
        systemProperty 'test.server.standalone', standaloneHosts
        systemProperty 'test.server.standalone.tls', standaloneTlsHosts
        systemProperty 'test.server.cluster', clusterHosts
        systemProperty 'test.server.cluster.tls', clusterTlsHosts
        systemProperty 'test.server.azcluster', azClusterHosts
        systemProperty 'test.server.tls', System.getProperty("tls")
        
        // Filter tests to focus on specific failing cluster TLS tests only
        if (System.getProperty("focusTests") == "true") {
            filter {
                includeTestsMatching "*ClusterTlsCertificateTest.testClusterTlsWithSelfSignedCertificateSucceeds*"
                includeTestsMatching "*ClusterTlsCertificateTest.testClusterTlsWithMultipleCertificatesSucceeds*"
                includeTestsMatching "*ClusterTlsCertificateTest.testClusterTlsWithKeyStoreSucceeds*"
            }
        }
    }

    testLogging {
        exceptionFormat "full"
        events "started", "skipped", "passed", "failed"
        showStandardStreams true
    }

    minHeapSize = "2048m" // Initial heap size. Needed for max size tests.
    maxHeapSize = "2048m" // Maximum heap size. Needed for max size tests.

    // Native library path for GLIDE FFI - needed for Jedis compatibility tests
    jvmArgs "-Djava.library.path=${project.rootDir}/../target/release"

    // Disable modularity for jedis compatibility tests
    if (name.contains('jedis') || filter.includePatterns.any { it.contains('jedis') }) {
        jvmArgs += "--add-opens=java.base/java.lang=ALL-UNNAMED"
        jvmArgs += "--add-opens=java.base/java.util=ALL-UNNAMED"
    }

    afterTest { desc, result ->
        logger.quiet "${desc.className}.${desc.name}: ${result.resultType} ${(result.getEndTime() - result.getStartTime())/1000}s"
    }

    finalizedBy jacocoTestReport, jacocoTestCoverageVerification
}

// JaCoCo section (code coverage by integration tests)
jacocoTestReport {
    sourceDirectories.setFrom(files("${project.rootDir}/client/src/main/java"))
    classDirectories.setFrom(files("$buildDir/classes"))
    executionData.setFrom(
        files("$buildDir/jacoco/test.exec"),
        files("$buildDir/jacoco/pubsubTest.exec")
    )
}
jacocoTestCoverageVerification {
    violationRules {
        rule {
            element = 'CLASS'
            excludes = [
                'glide.models.protobuf.*',
                'glide.com.google.*', // shadowed protobuf
                'glide.io.netty.*' // shadowed netty
            ]
        }
    }
}
// End of JaCoCo section

test {
    filter {
        excludeTestsMatching 'glide.PubSubTests'
        excludeTestsMatching 'glide.modules.*'
        
        // When focusing on cluster TLS tests, exclude everything else
        if (System.getProperty("focusTests") == "true") {
            excludeTestsMatching 'glide.*CommandTests*'
            excludeTestsMatching 'glide.*BatchTests*'
            excludeTestsMatching 'compatibility.jedis.*'
            excludeTestsMatching 'glide.*AsyncTests*'
            excludeTestsMatching 'glide.*TransactionTests*'
            excludeTestsMatching 'glide.*ConnectionTests*'
            excludeTestsMatching 'glide.standalone.*'
            excludeTestsMatching 'glide.cluster.ClusterConnectionTests*'
            excludeTestsMatching 'glide.cluster.ClusterCommandTests*'
        }
    }
}

tasks.register('pubsubTest', Test) {
    filter {
        includeTestsMatching 'glide.PubSubTests'
    }
    finalizedBy jacocoTestReport, jacocoTestCoverageVerification
}

tasks.register('modulesTest', Test) {
    doFirst {
        clusterHosts = System.getProperty("cluster-endpoints")
    }

    filter {
        includeTestsMatching 'glide.modules.*'
    }
}
