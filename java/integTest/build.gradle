plugins {
    id 'java-library'
}

repositories {
    mavenCentral()
}

dependencies {
    // client
    implementation project(':client')

    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.13.0'

    // https://github.com/netty/netty/wiki/Native-transports
    // At the moment, Windows is not supported
    implementation group: 'io.netty', name: 'netty-transport-native-epoll', version: '4.1.100.Final', classifier: 'linux-x86_64'
    implementation group: 'io.netty', name: 'netty-transport-native-kqueue', version: '4.1.100.Final', classifier: 'osx-x86_64'
    implementation group: 'io.netty', name: 'netty-transport-native-kqueue', version: '4.1.100.Final', classifier: 'osx-aarch_64'

    // junit
    testImplementation 'org.mockito:mockito-junit-jupiter:3.12.4'
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter', version: '5.10.2'

    // semver4j for semantic versioning
    implementation 'com.vdurmont:semver4j:3.1.0'

    //lombok
    testCompileOnly 'org.projectlombok:lombok:1.18.32'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.32'
}

def standaloneHosts = ''
def clusterHosts = ''
def serverVersion = ""

ext {
    extractAddressesFromClusterManagerOutput = { String output ->
        for (def line : output.split("\n")) {
            if (!line.startsWith("CLUSTER_NODES="))
                continue

            return line.split("=")[1]
        }
        return ''
    }
    extractServerVersion = { String output ->
        // Redis response:
        // Redis server v=7.2.3 sha=00000000:0 malloc=jemalloc-5.3.0 bits=64 build=7504b1fedf883f2
        // Valkey response:
        // Server v=7.2.5 sha=26388270:0 malloc=jemalloc-5.3.0 bits=64 build=ea40bb1576e402d6
        return output.split("v=")[1].split(" ")[0]
    }
}

tasks.register('stopAllAfterTests', Exec) {
    workingDir "${project.rootDir}/../utils"
    commandLine 'python3', 'cluster_manager.py', 'stop', '--prefix', 'redis-cluster', '--keep-folder'
}

// We need to call for stop before and after the test, but gradle doesn't support executing a task
// twice. So there are two identical tasks with different names.
// We need to call for stop in case if previous test run was interrupted/crashed and didn't stop.
tasks.register('stopAllBeforeTests', Exec) {
    workingDir "${project.rootDir}/../utils"
    commandLine 'python3', 'cluster_manager.py', 'stop', '--prefix', 'redis-cluster'
    ignoreExitValue true // ignore fail if servers are stopped before
}

// delete dirs if stop failed due to https://github.com/valkey-io/valkey-glide/issues/849
tasks.register('clearDirs', Delete) {
    delete "${project.rootDir}/../utils/clusters"
}

tasks.register('startCluster') {
    doLast {
        if (System.getProperty("cluster-endpoints") == null) {
            new ByteArrayOutputStream().withStream { os ->
                exec {
                    workingDir "${project.rootDir}/../utils"
                    commandLine 'python3', 'cluster_manager.py', 'start', '--cluster-mode'
                    standardOutput = os
                }
                clusterHosts = extractAddressesFromClusterManagerOutput(os.toString())
            }
        } else {
            clusterHosts = System.getProperty("cluster-endpoints")
        }
    }
}

tasks.register('startStandalone') {
    doLast {
        if (System.getProperty("standalone-endpoints") == null) {
            new ByteArrayOutputStream().withStream { os ->
                exec {
                    workingDir "${project.rootDir}/../utils"
                    commandLine 'python3', 'cluster_manager.py', 'start', '-r', '0'
                    standardOutput = os
                }
                standaloneHosts = extractAddressesFromClusterManagerOutput(os.toString())
            }
        } else {
            standaloneHosts = System.getProperty("standalone-endpoints")
        }
    }
}

tasks.register('getServerVersion') {
    doLast {
        def detectedVersion
        def output = new ByteArrayOutputStream()

        // Helper method to find the full path of a command
        def findFullPath = { command ->
            def pathOutput = new ByteArrayOutputStream()
            try {
                exec {
                    commandLine 'which', command  // Use 'where' for Windows
                    standardOutput = pathOutput
                }
                return pathOutput.toString().trim()
            } catch (Exception e) {
                println "Failed to find path for ${command}: ${e.message}"
                return ""
            }
        }

        // Get full paths
        def valkeyPath = findFullPath('valkey-server')
        def redisPath = findFullPath('redis-server')

        def tryGetVersion = { serverPath ->
            try {
                exec {
                    commandLine serverPath, '-v'
                    standardOutput = output
                }
                return output.toString()
            } catch (Exception e) {
                println "Failed to execute ${serverPath}: ${e.message}"
                return ""
            }
        }

        // Try valkey-server first, then redis-server if it fails
        def versionOutput = tryGetVersion(valkeyPath)
        if (versionOutput.isEmpty() && !redisPath.isEmpty()) {
            versionOutput = tryGetVersion(redisPath)
        }

        if (!versionOutput.isEmpty()) {
            detectedVersion = extractServerVersion(versionOutput)
            println "Detected server version: ${detectedVersion}"
            serverVersion = detectedVersion
        } else {
            throw new GradleException("Failed to retrieve the server version.")
        }
    }
}

test.dependsOn 'stopAllBeforeTests'
test.dependsOn 'getServerVersion'
stopAllBeforeTests.finalizedBy 'clearDirs'
clearDirs.finalizedBy 'startStandalone'
clearDirs.finalizedBy 'startCluster'
test.finalizedBy 'stopAllAfterTests'
test.dependsOn ':client:buildRustRelease'

tasks.withType(Test) {
    doFirst {
        println "Cluster hosts = ${clusterHosts}"
        println "Standalone hosts = ${standaloneHosts}"
        println "Server version = ${serverVersion}"
        systemProperty 'test.server.standalone', standaloneHosts
        systemProperty 'test.server.cluster', clusterHosts
        systemProperty 'test.server.version', serverVersion
    }

    testLogging {
        exceptionFormat "full"
        events "started", "skipped", "passed", "failed"
        showStandardStreams true
    }

    minHeapSize = "2048m" // Initial heap size. Needed for max size tests.
    maxHeapSize = "2048m" // Maximum heap size. Needed for max size tests.

    afterTest { desc, result ->
        logger.quiet "${desc.className}.${desc.name}: ${result.resultType} ${(result.getEndTime() - result.getStartTime())/1000}s"
    }
}
