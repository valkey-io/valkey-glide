/**
 * Copyright Valkey GLIDE Project Contributors - SPDX Identifier: Apache-2.0
 */

import {
    afterAll,
    afterEach,
    beforeAll,
    describe,
    expect,
    it,
} from "@jest/globals";
import { BufferReader, BufferWriter } from "protobufjs";
import { v4 as uuidv4 } from "uuid";
import {
    Decoder,
    GlideClient,
    ListDirection,
    ProtocolVersion,
    RequestError,
    Transaction,
} from "..";
import { RedisCluster } from "../../utils/TestUtils.js";
import { FlushMode, SortOrder } from "../build-ts/src/Commands";
import { command_request } from "../src/ProtobufMessage";
import { runBaseTests } from "./SharedTests";
import {
    checkFunctionListResponse,
    checkFunctionStatsResponse,
    convertStringArrayToBuffer,
    createLuaLibWithLongRunningFunction,
    encodableTransactionTest,
    encodedTransactionTest,
    flushAndCloseClient,
    generateLuaLibCode,
    getClientConfigurationOption,
    parseCommandLineArgs,
    parseEndpoints,
    transactionTest,
    validateTransactionResponse,
    waitForNotBusy,
} from "./TestUtilities";

/* eslint-disable @typescript-eslint/no-var-requires */

type Context = {
    client: GlideClient;
};

const TIMEOUT = 50000;

describe("GlideClient", () => {
    let testsFailed = 0;
    let cluster: RedisCluster;
    let client: GlideClient;
    beforeAll(async () => {
        const standaloneAddresses =
            parseCommandLineArgs()["standalone-endpoints"];
        // Connect to cluster or create a new one based on the parsed addresses
        cluster = standaloneAddresses
            ? await RedisCluster.initFromExistingCluster(
                  parseEndpoints(standaloneAddresses),
              )
            : await RedisCluster.createCluster(false, 1, 1);
    }, 20000);

    afterEach(async () => {
        await flushAndCloseClient(false, cluster.getAddresses(), client);
    });

    afterAll(async () => {
        if (testsFailed === 0) {
            await cluster.close();
        }
    }, TIMEOUT);

    it("test protobuf encode/decode delimited", () => {
        // This test is required in order to verify that the autogenerated protobuf
        // files has been corrected and the encoding/decoding works as expected.
        // See "Manually compile protobuf files" in node/README.md to get more info about the fix.
        const writer = new BufferWriter();
        const request = {
            callbackIdx: 1,
            singleCommand: {
                requestType: 2,
                argsArray: command_request.Command.ArgsArray.create({
                    args: convertStringArrayToBuffer(["bar1", "bar2"]),
                }),
            },
        };
        const request2 = {
            callbackIdx: 3,
            singleCommand: {
                requestType: 4,
                argsArray: command_request.Command.ArgsArray.create({
                    args: convertStringArrayToBuffer(["bar3", "bar4"]),
                }),
            },
        };
        command_request.CommandRequest.encodeDelimited(request, writer);
        command_request.CommandRequest.encodeDelimited(request2, writer);
        const buffer = writer.finish();
        const reader = new BufferReader(buffer);

        const dec_msg1 = command_request.CommandRequest.decodeDelimited(reader);
        expect(dec_msg1.callbackIdx).toEqual(1);
        expect(dec_msg1.singleCommand?.requestType).toEqual(2);
        expect(dec_msg1.singleCommand?.argsArray?.args).toEqual(
            convertStringArrayToBuffer(["bar1", "bar2"]),
        );

        const dec_msg2 = command_request.CommandRequest.decodeDelimited(reader);
        expect(dec_msg2.callbackIdx).toEqual(3);
        expect(dec_msg2.singleCommand?.requestType).toEqual(4);
        expect(dec_msg2.singleCommand?.argsArray?.args).toEqual(
            convertStringArrayToBuffer(["bar3", "bar4"]),
        );
    });

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "info without parameters",
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const result = await client.info();
            expect(result).toEqual(expect.stringContaining("# Server"));
            expect(result).toEqual(expect.stringContaining("# Replication"));
            expect(result).toEqual(
                expect.not.stringContaining("# Latencystats"),
            );
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "check that blocking commands returns never timeout_%p",
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(
                    cluster.getAddresses(),
                    protocol,
                    300,
                ),
            );

            const promiseList = [
                client.blmove(
                    "source",
                    "destination",
                    ListDirection.LEFT,
                    ListDirection.LEFT,
                    0.1,
                ),
                client.blmpop(["key1", "key2"], ListDirection.LEFT, 0.1),
                client.bzpopmax(["key1", "key2"], 0),
                client.bzpopmin(["key1", "key2"], 0),
            ];

            try {
                for (const promise of promiseList) {
                    const timeoutPromise = new Promise((resolve) => {
                        setTimeout(resolve, 500);
                    });
                    await Promise.race([promise, timeoutPromise]);
                }
            } finally {
                for (const promise of promiseList) {
                    await Promise.resolve([promise]);
                }

                client.close();
            }
        },
        5000,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "select dbsize flushdb test %p",
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            expect(await client.select(0)).toEqual("OK");

            const key = uuidv4();
            const value = uuidv4();
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.select(1)).toEqual("OK");
            expect(await client.get(key)).toEqual(null);
            expect(await client.flushdb()).toEqual("OK");
            expect(await client.dbsize()).toEqual(0);

            expect(await client.select(0)).toEqual("OK");
            expect(await client.get(key)).toEqual(value);

            expect(await client.dbsize()).toBeGreaterThan(0);
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");
            expect(await client.dbsize()).toEqual(0);
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "bytes decoder client test %p",
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.Bytes;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");

            const key = uuidv4();
            const value = uuidv4();
            const valueEncoded = Buffer.from(value);
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.get(key)).toEqual(valueEncoded);
            expect(await client.get(key, Decoder.String)).toEqual(value);
            expect(await client.get(key, Decoder.Bytes)).toEqual(valueEncoded);
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "string decoder client test %p",
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.String;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");

            const key = uuidv4();
            const value = uuidv4();
            const valueEncoded = Buffer.from(value);
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.get(key)).toEqual(value);
            expect(await client.get(key, Decoder.String)).toEqual(value);
            expect(await client.get(key, Decoder.Bytes)).toEqual(valueEncoded);
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        `can send transactions_%p`,
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const transaction = new Transaction();
            const expectedRes = await transactionTest(
                transaction,
                cluster.getVersion(),
            );
            transaction.select(0);
            const result = await client.exec(transaction);
            expectedRes.push(["select(0)", "OK"]);

            validateTransactionResponse(result, expectedRes);
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        `can get Bytes decoded transactions_%p`,
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const transaction = new Transaction();
            const expectedRes = await encodedTransactionTest(transaction);
            transaction.select(0);
            const result = await client.exec(transaction, Decoder.Bytes);
            expectedRes.push(["select(0)", "OK"]);

            validateTransactionResponse(result, expectedRes);
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        `can send transaction with default string decoder_%p`,
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.String;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");
            const transaction = new Transaction();
            const expectedRes = await encodableTransactionTest(
                transaction,
                "value",
            );
            transaction.select(0);
            const result = await client.exec(transaction);
            expectedRes.push(["select(0)", "OK"]);

            validateTransactionResponse(result, expectedRes);
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        `can send transaction with default bytes decoder_%p`,
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.Bytes;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");
            const transaction = new Transaction();
            const valueEncoded = Buffer.from("value");
            const expectedRes = await encodableTransactionTest(
                transaction,
                valueEncoded,
            );
            transaction.select(0);
            const result = await client.exec(transaction);
            expectedRes.push(["select(0)", "OK"]);

            validateTransactionResponse(result, expectedRes);
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "can return null on WATCH transaction failures",
        async (protocol) => {
            const client1 = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const client2 = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const transaction = new Transaction();
            transaction.get("key");
            const result1 = await client1.watch(["key"]);
            expect(result1).toEqual("OK");

            const result2 = await client2.set("key", "foo");
            expect(result2).toEqual("OK");

            const result3 = await client1.exec(transaction);
            expect(result3).toBeNull();

            client1.close();
            client2.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "object freq transaction test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();
            const maxmemoryPolicyKey = "maxmemory-policy";
            const config = await client.configGet([maxmemoryPolicyKey]);
            const maxmemoryPolicy = String(config[maxmemoryPolicyKey]);

            try {
                const transaction = new Transaction();
                transaction.configSet({
                    [maxmemoryPolicyKey]: "allkeys-lfu",
                });
                transaction.set(key, "foo");
                transaction.objectFreq(key);

                const response = await client.exec(transaction);
                expect(response).not.toBeNull();

                if (response != null) {
                    expect(response.length).toEqual(3);
                    expect(response[0]).toEqual("OK");
                    expect(response[1]).toEqual("OK");
                    expect(response[2]).toBeGreaterThanOrEqual(0);
                }
            } finally {
                expect(
                    await client.configSet({
                        [maxmemoryPolicyKey]: maxmemoryPolicy,
                    }),
                ).toEqual("OK");
            }

            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "object idletime transaction test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();
            const maxmemoryPolicyKey = "maxmemory-policy";
            const config = await client.configGet([maxmemoryPolicyKey]);
            const maxmemoryPolicy = String(config[maxmemoryPolicyKey]);

            try {
                const transaction = new Transaction();
                transaction.configSet({
                    // OBJECT IDLETIME requires a non-LFU maxmemory-policy
                    [maxmemoryPolicyKey]: "allkeys-random",
                });
                transaction.set(key, "foo");
                transaction.objectIdletime(key);

                const response = await client.exec(transaction);
                expect(response).not.toBeNull();

                if (response != null) {
                    expect(response.length).toEqual(3);
                    // transaction.configSet({[maxmemoryPolicyKey]: "allkeys-random"});
                    expect(response[0]).toEqual("OK");
                    // transaction.set(key, "foo");
                    expect(response[1]).toEqual("OK");
                    // transaction.objectIdletime(key);
                    expect(response[2]).toBeGreaterThanOrEqual(0);
                }
            } finally {
                expect(
                    await client.configSet({
                        [maxmemoryPolicyKey]: maxmemoryPolicy,
                    }),
                ).toEqual("OK");
            }

            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "object refcount transaction test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();
            const transaction = new Transaction();
            transaction.set(key, "foo");
            transaction.objectRefcount(key);

            const response = await client.exec(transaction);
            expect(response).not.toBeNull();

            if (response != null) {
                expect(response.length).toEqual(2);
                expect(response[0]).toEqual("OK"); // transaction.set(key, "foo");
                expect(response[1]).toBeGreaterThanOrEqual(1); // transaction.objectRefcount(key);
            }

            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "lolwut test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const result = await client.lolwut();
            expect(result).toEqual(expect.stringContaining("Redis ver. "));

            const result2 = await client.lolwut({ parameters: [] });
            expect(result2).toEqual(expect.stringContaining("Redis ver. "));

            const result3 = await client.lolwut({ parameters: [50, 20] });
            expect(result3).toEqual(expect.stringContaining("Redis ver. "));

            const result4 = await client.lolwut({ version: 6 });
            expect(result4).toEqual(expect.stringContaining("Redis ver. "));

            const result5 = await client.lolwut({
                version: 5,
                parameters: [30, 4, 4],
            });
            expect(result5).toEqual(expect.stringContaining("Redis ver. "));

            // transaction tests
            const transaction = new Transaction();
            transaction.lolwut();
            transaction.lolwut({ version: 5 });
            transaction.lolwut({ parameters: [1, 2] });
            transaction.lolwut({ version: 6, parameters: [42] });
            const results = await client.exec(transaction);

            if (results) {
                for (const element of results) {
                    expect(element).toEqual(
                        expect.stringContaining("Redis ver. "),
                    );
                }
            } else {
                throw new Error("Invalid LOLWUT transaction test results.");
            }

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "copy with DB test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("6.2.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const source = `{key}-${uuidv4()}`;
            const destination = `{key}-${uuidv4()}`;
            const value1 = uuidv4();
            const value2 = uuidv4();
            const index0 = 0;
            const index1 = 1;
            const index2 = 2;

            // neither key exists
            expect(
                await client.copy(source, destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(false);

            // source exists, destination does not
            expect(await client.set(source, value1)).toEqual("OK");
            expect(
                await client.copy(source, destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(true);
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value1);

            // new value for source key
            expect(await client.select(index0)).toEqual("OK");
            expect(await client.set(source, value2)).toEqual("OK");

            // no REPLACE, copying to existing key on DB 1, non-existing key on DB 2
            expect(
                await client.copy(source, destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(false);
            expect(
                await client.copy(source, destination, {
                    destinationDB: index2,
                    replace: false,
                }),
            ).toEqual(true);

            // new value only gets copied to DB 2
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value1);
            expect(await client.select(index2)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value2);

            // both exists, with REPLACE, when value isn't the same, source always get copied to
            // destination
            expect(await client.select(index0)).toEqual("OK");
            expect(
                await client.copy(source, destination, {
                    destinationDB: index1,
                    replace: true,
                }),
            ).toEqual(true);
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value2);

            //transaction tests
            const transaction = new Transaction();
            transaction.select(index1);
            transaction.set(source, value1);
            transaction.copy(source, destination, {
                destinationDB: index1,
                replace: true,
            });
            transaction.get(destination);
            const results = await client.exec(transaction);

            expect(results).toEqual(["OK", "OK", true, value1]);

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "move test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + uuidv4();
            const key2 = "{key}-2" + uuidv4();
            const value = uuidv4();

            expect(await client.select(0)).toEqual("OK");
            expect(await client.move(key1, 1)).toEqual(false);

            expect(await client.set(key1, value)).toEqual("OK");
            expect(await client.get(key1)).toEqual(value);
            expect(await client.move(key1, 1)).toEqual(true);
            expect(await client.get(key1)).toEqual(null);
            expect(await client.select(1)).toEqual("OK");
            expect(await client.get(key1)).toEqual(value);

            await expect(client.move(key1, -1)).rejects.toThrow(RequestError);

            //transaction tests
            const transaction = new Transaction();
            transaction.select(1);
            transaction.move(key2, 0);
            transaction.set(key2, value);
            transaction.move(key2, 0);
            transaction.select(0);
            transaction.get(key2);
            const results = await client.exec(transaction);

            expect(results).toEqual(["OK", false, "OK", true, "OK", value]);

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function load function list function stats test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + uuidv4().replaceAll("-", "");
                const funcName = "myfunc1c" + uuidv4().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(code)).toEqual(libName);

                expect(
                    await client.fcall(funcName, [], ["one", "two"]),
                ).toEqual("one");
                expect(
                    await client.fcallReadonly(funcName, [], ["one", "two"]),
                ).toEqual("one");

                let functionStats = await client.functionStats();
                checkFunctionStatsResponse(functionStats, [], 1, 1);

                let functionList = await client.functionList({
                    libNamePattern: libName,
                });
                let expectedDescription = new Map<string, string | null>([
                    [funcName, null],
                ]);
                let expectedFlags = new Map<string, string[]>([
                    [funcName, ["no-writes"]],
                ]);

                checkFunctionListResponse(
                    functionList,
                    libName,
                    expectedDescription,
                    expectedFlags,
                );

                // re-load library without replace

                await expect(client.functionLoad(code)).rejects.toThrow(
                    `Library '${libName}' already exists`,
                );

                // re-load library with replace
                expect(await client.functionLoad(code, true)).toEqual(libName);

                // overwrite lib with new code
                const func2Name = "myfunc2c" + uuidv4().replaceAll("-", "");
                const newCode = generateLuaLibCode(
                    libName,
                    new Map([
                        [funcName, "return args[1]"],
                        [func2Name, "return #args"],
                    ]),
                    true,
                );
                expect(await client.functionLoad(newCode, true)).toEqual(
                    libName,
                );

                functionList = await client.functionList({ withCode: true });
                expectedDescription = new Map<string, string | null>([
                    [funcName, null],
                    [func2Name, null],
                ]);
                expectedFlags = new Map<string, string[]>([
                    [funcName, ["no-writes"]],
                    [func2Name, ["no-writes"]],
                ]);

                checkFunctionListResponse(
                    functionList,
                    libName,
                    expectedDescription,
                    expectedFlags,
                    newCode,
                );

                functionStats = await client.functionStats();
                checkFunctionStatsResponse(functionStats, [], 1, 2);

                expect(
                    await client.fcall(func2Name, [], ["one", "two"]),
                ).toEqual(2);
                expect(
                    await client.fcallReadonly(func2Name, [], ["one", "two"]),
                ).toEqual(2);
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                const functionStats = await client.functionStats();
                checkFunctionStatsResponse(functionStats, [], 0, 0);
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function flush test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + uuidv4().replaceAll("-", "");
                const funcName = "myfunc1c" + uuidv4().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(code)).toEqual(libName);

                // Flush functions
                expect(await client.functionFlush(FlushMode.SYNC)).toEqual(
                    "OK",
                );
                expect(await client.functionFlush(FlushMode.ASYNC)).toEqual(
                    "OK",
                );

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                // Attempt to re-load library without overwriting to ensure FLUSH was effective
                expect(await client.functionLoad(code)).toEqual(libName);
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function delete test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + uuidv4().replaceAll("-", "");
                const funcName = "myfunc1c" + uuidv4().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );
                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(code)).toEqual(libName);

                // Delete the function
                expect(await client.functionDelete(libName)).toEqual("OK");

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                // deleting a non-existing library
                await expect(client.functionDelete(libName)).rejects.toThrow(
                    `Library not found`,
                );
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function kill RO func %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                10000,
            );
            const client = await GlideClient.createClient(config);
            const testClient = await GlideClient.createClient(config);

            try {
                const libName = "function_kill_no_write";
                const funcName = "deadlock_no_write";
                const code = createLuaLibWithLongRunningFunction(
                    libName,
                    funcName,
                    6,
                    true,
                );
                expect(await client.functionFlush()).toEqual("OK");
                // nothing to kill
                await expect(client.functionKill()).rejects.toThrow(/notbusy/i);

                // load the lib
                expect(await client.functionLoad(code, true)).toEqual(libName);

                try {
                    // call the function without await
                    const promise = testClient
                        .fcall(funcName, [], [])
                        .catch((e) =>
                            expect((e as Error).message).toContain(
                                "Script killed",
                            ),
                        );

                    let killed = false;
                    let timeout = 4000;
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    while (timeout >= 0) {
                        try {
                            expect(await client.functionKill()).toEqual("OK");
                            killed = true;
                            break;
                        } catch {
                            // do nothing
                        }

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );
                        timeout -= 500;
                    }

                    expect(killed).toBeTruthy();
                    await promise;
                } finally {
                    await waitForNotBusy(client);
                }
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                testClient.close();
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function kill RW func %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                10000,
            );
            const client = await GlideClient.createClient(config);
            const testClient = await GlideClient.createClient(config);

            try {
                const libName = "function_kill_write";
                const key = libName;
                const funcName = "deadlock_write";
                const code = createLuaLibWithLongRunningFunction(
                    libName,
                    funcName,
                    6,
                    false,
                );
                expect(await client.functionFlush()).toEqual("OK");
                // nothing to kill
                await expect(client.functionKill()).rejects.toThrow(/notbusy/i);

                // load the lib
                expect(await client.functionLoad(code, true)).toEqual(libName);

                let promise = null;

                try {
                    // call the function without await
                    promise = testClient.fcall(funcName, [key], []);

                    let foundUnkillable = false;
                    let timeout = 4000;
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    while (timeout >= 0) {
                        try {
                            // valkey kills a function with 5 sec delay
                            // but this will always throw an error in the test
                            await client.functionKill();
                        } catch (err) {
                            // looking for an error with "unkillable" in the message
                            // at that point we can break the loop
                            if (
                                (err as Error).message
                                    .toLowerCase()
                                    .includes("unkillable")
                            ) {
                                foundUnkillable = true;
                                break;
                            }
                        }

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );
                        timeout -= 500;
                    }

                    expect(foundUnkillable).toBeTruthy();
                } finally {
                    // If function wasn't killed, and it didn't time out - it blocks the server and cause rest
                    // test to fail. Wait for the function to complete (we cannot kill it)
                    expect(await promise).toContain("Timed out");
                }
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                testClient.close();
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "sort sortstore sort_store sortro sort_ro sortreadonly test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const setPrefix = "setKey" + uuidv4();
            const hashPrefix = "hashKey" + uuidv4();
            const list = uuidv4();
            const store = uuidv4();
            const names = ["Alice", "Bob", "Charlie", "Dave", "Eve"];
            const ages = ["30", "25", "35", "20", "40"];

            for (let i = 0; i < ages.length; i++) {
                expect(
                    await client.hset(setPrefix + (i + 1), {
                        name: names[i],
                        age: ages[i],
                    }),
                ).toEqual(2);
            }

            expect(await client.rpush(list, ["3", "1", "5", "4", "2"])).toEqual(
                5,
            );

            expect(
                await client.sort(list, {
                    limit: { offset: 0, count: 2 },
                    getPatterns: [setPrefix + "*->name"],
                }),
            ).toEqual(["Alice", "Bob"]);

            expect(
                await client.sort(list, {
                    limit: { offset: 0, count: 2 },
                    getPatterns: [setPrefix + "*->name"],
                    orderBy: SortOrder.DESC,
                }),
            ).toEqual(["Eve", "Dave"]);

            expect(
                await client.sort(list, {
                    limit: { offset: 0, count: 2 },
                    byPattern: setPrefix + "*->age",
                    getPatterns: [setPrefix + "*->name", setPrefix + "*->age"],
                    orderBy: SortOrder.DESC,
                }),
            ).toEqual(["Eve", "40", "Charlie", "35"]);

            // Non-existent key in the BY pattern will result in skipping the sorting operation
            expect(await client.sort(list, { byPattern: "noSort" })).toEqual([
                "3",
                "1",
                "5",
                "4",
                "2",
            ]);

            // Non-existent key in the GET pattern results in nulls
            expect(
                await client.sort(list, {
                    isAlpha: true,
                    getPatterns: ["missing"],
                }),
            ).toEqual([null, null, null, null, null]);

            // Missing key in the set
            expect(await client.lpush(list, ["42"])).toEqual(6);
            expect(
                await client.sort(list, {
                    byPattern: setPrefix + "*->age",
                    getPatterns: [setPrefix + "*->name"],
                }),
            ).toEqual([null, "Dave", "Bob", "Alice", "Charlie", "Eve"]);
            expect(await client.lpop(list)).toEqual("42");

            // sort RO
            if (!cluster.checkIfServerVersionLessThan("7.0.0")) {
                expect(
                    await client.sortReadOnly(list, {
                        limit: { offset: 0, count: 2 },
                        getPatterns: [setPrefix + "*->name"],
                    }),
                ).toEqual(["Alice", "Bob"]);

                expect(
                    await client.sortReadOnly(list, {
                        limit: { offset: 0, count: 2 },
                        getPatterns: [setPrefix + "*->name"],
                        orderBy: SortOrder.DESC,
                    }),
                ).toEqual(["Eve", "Dave"]);

                expect(
                    await client.sortReadOnly(list, {
                        limit: { offset: 0, count: 2 },
                        byPattern: setPrefix + "*->age",
                        getPatterns: [
                            setPrefix + "*->name",
                            setPrefix + "*->age",
                        ],
                        orderBy: SortOrder.DESC,
                    }),
                ).toEqual(["Eve", "40", "Charlie", "35"]);

                // Non-existent key in the BY pattern will result in skipping the sorting operation
                expect(
                    await client.sortReadOnly(list, { byPattern: "noSort" }),
                ).toEqual(["3", "1", "5", "4", "2"]);

                // Non-existent key in the GET pattern results in nulls
                expect(
                    await client.sortReadOnly(list, {
                        isAlpha: true,
                        getPatterns: ["missing"],
                    }),
                ).toEqual([null, null, null, null, null]);

                // Missing key in the set
                expect(await client.lpush(list, ["42"])).toEqual(6);
                expect(
                    await client.sortReadOnly(list, {
                        byPattern: setPrefix + "*->age",
                        getPatterns: [setPrefix + "*->name"],
                    }),
                ).toEqual([null, "Dave", "Bob", "Alice", "Charlie", "Eve"]);
                expect(await client.lpop(list)).toEqual("42");
            }

            // SORT with STORE
            expect(
                await client.sortStore(list, store, {
                    limit: { offset: 0, count: -1 },
                    byPattern: setPrefix + "*->age",
                    getPatterns: [setPrefix + "*->name"],
                    orderBy: SortOrder.ASC,
                }),
            ).toEqual(5);
            expect(await client.lrange(store, 0, -1)).toEqual([
                "Dave",
                "Bob",
                "Alice",
                "Charlie",
                "Eve",
            ]);
            expect(
                await client.sortStore(list, store, {
                    byPattern: setPrefix + "*->age",
                    getPatterns: [setPrefix + "*->name"],
                }),
            ).toEqual(5);
            expect(await client.lrange(store, 0, -1)).toEqual([
                "Dave",
                "Bob",
                "Alice",
                "Charlie",
                "Eve",
            ]);

            // transaction test
            const transaction = new Transaction()
                .hset(hashPrefix + 1, { name: "Alice", age: "30" })
                .hset(hashPrefix + 2, { name: "Bob", age: "25" })
                .del([list])
                .lpush(list, ["2", "1"])
                .sort(list, {
                    byPattern: hashPrefix + "*->age",
                    getPatterns: [hashPrefix + "*->name"],
                })
                .sort(list, {
                    byPattern: hashPrefix + "*->age",
                    getPatterns: [hashPrefix + "*->name"],
                    orderBy: SortOrder.DESC,
                })
                .sortStore(list, store, {
                    byPattern: hashPrefix + "*->age",
                    getPatterns: [hashPrefix + "*->name"],
                })
                .lrange(store, 0, -1)
                .sortStore(list, store, {
                    byPattern: hashPrefix + "*->age",
                    getPatterns: [hashPrefix + "*->name"],
                    orderBy: SortOrder.DESC,
                })
                .lrange(store, 0, -1);

            if (!cluster.checkIfServerVersionLessThan("7.0.0")) {
                transaction
                    .sortReadOnly(list, {
                        byPattern: hashPrefix + "*->age",
                        getPatterns: [hashPrefix + "*->name"],
                    })
                    .sortReadOnly(list, {
                        byPattern: hashPrefix + "*->age",
                        getPatterns: [hashPrefix + "*->name"],
                        orderBy: SortOrder.DESC,
                    });
            }

            const expectedResult = [
                2,
                2,
                1,
                2,
                ["Bob", "Alice"],
                ["Alice", "Bob"],
                2,
                ["Bob", "Alice"],
                2,
                ["Alice", "Bob"],
            ];

            if (!cluster.checkIfServerVersionLessThan("7.0.0")) {
                expectedResult.push(["Bob", "Alice"], ["Alice", "Bob"]);
            }

            const result = await client.exec(transaction);
            expect(result).toEqual(expectedResult);

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "randomKey test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();

            // setup: delete all keys in DB 0 and DB 1
            expect(await client.select(0)).toEqual("OK");
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");
            expect(await client.select(1)).toEqual("OK");
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");

            // no keys exist so randomKey returns null
            expect(await client.randomKey()).toBeNull();
            // set `key` in DB 1
            expect(await client.set(key, "foo")).toEqual("OK");
            // `key` should be the only key in the database
            expect(await client.randomKey()).toEqual(key);

            // switch back to DB 0
            expect(await client.select(0)).toEqual("OK");
            // DB 0 should still have no keys, so randomKey should still return null
            expect(await client.randomKey()).toBeNull();

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "watch test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + uuidv4();
            const key2 = "{key}-2" + uuidv4();
            const key3 = "{key}-3" + uuidv4();
            const key4 = "{key}-4" + uuidv4();
            const setFoobarTransaction = new Transaction();
            const setHelloTransaction = new Transaction();

            // Returns null when a watched key is modified before it is executed in a transaction command.
            // Transaction commands are not performed.
            expect(await client.watch([key1, key2, key3])).toEqual("OK");
            expect(await client.set(key2, "hello")).toEqual("OK");
            setFoobarTransaction
                .set(key1, "foobar")
                .set(key2, "foobar")
                .set(key3, "foobar");
            let results = await client.exec(setFoobarTransaction);
            expect(results).toEqual(null);
            // sanity check
            expect(await client.get(key1)).toEqual(null);
            expect(await client.get(key2)).toEqual("hello");
            expect(await client.get(key3)).toEqual(null);

            // Transaction executes command successfully with a read command on the watch key before
            // transaction is executed.
            expect(await client.watch([key1, key2, key3])).toEqual("OK");
            expect(await client.get(key2)).toEqual("hello");
            results = await client.exec(setFoobarTransaction);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");
            expect(await client.get(key3)).toEqual("foobar");

            // Transaction executes command successfully with unmodified watched keys
            expect(await client.watch([key1, key2, key3])).toEqual("OK");
            results = await client.exec(setFoobarTransaction);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");
            expect(await client.get(key3)).toEqual("foobar");

            // Transaction executes command successfully with a modified watched key but is not in the
            // transaction.
            expect(await client.watch([key4])).toEqual("OK");
            setHelloTransaction
                .set(key1, "hello")
                .set(key2, "hello")
                .set(key3, "hello");
            results = await client.exec(setHelloTransaction);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("hello");
            expect(await client.get(key2)).toEqual("hello");
            expect(await client.get(key3)).toEqual("hello");

            // WATCH can not have an empty String array parameter
            await expect(client.watch([])).rejects.toThrow(RequestError);

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "unwatch test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + uuidv4();
            const key2 = "{key}-2" + uuidv4();

            const setFoobarTransaction = new Transaction();

            // UNWATCH returns OK when there no watched keys
            expect(await client.unwatch()).toEqual("OK");

            // Transaction executes successfully after modifying a watched key then calling UNWATCH
            expect(await client.watch([key1, key2])).toEqual("OK");
            expect(await client.set(key2, "hello")).toEqual("OK");
            expect(await client.unwatch()).toEqual("OK");
            setFoobarTransaction.set(key1, "foobar").set(key2, "foobar");
            const results = await client.exec(setFoobarTransaction);
            expect(results).toEqual(["OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "xinfo stream transaction test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();

            const transaction = new Transaction();
            transaction.xadd(key, [["field1", "value1"]], { id: "0-1" });
            transaction.xinfoStream(key);
            transaction.xinfoStream(key, true);
            const result = await client.exec(transaction);
            expect(result).not.toBeNull();

            const versionLessThan7 =
                cluster.checkIfServerVersionLessThan("7.0.0");

            const expectedXinfoStreamResult = {
                length: 1,
                "radix-tree-keys": 1,
                "radix-tree-nodes": 2,
                "last-generated-id": "0-1",
                groups: 0,
                "first-entry": ["0-1", ["field1", "value1"]],
                "last-entry": ["0-1", ["field1", "value1"]],
                "max-deleted-entry-id": versionLessThan7 ? undefined : "0-0",
                "entries-added": versionLessThan7 ? undefined : 1,
                "recorded-first-entry-id": versionLessThan7 ? undefined : "0-1",
            };

            const expectedXinfoStreamFullResult = {
                length: 1,
                "radix-tree-keys": 1,
                "radix-tree-nodes": 2,
                "last-generated-id": "0-1",
                entries: [["0-1", ["field1", "value1"]]],
                groups: [],
                "max-deleted-entry-id": versionLessThan7 ? undefined : "0-0",
                "entries-added": versionLessThan7 ? undefined : 1,
                "recorded-first-entry-id": versionLessThan7 ? undefined : "0-1",
            };

            if (result != null) {
                expect(result[0]).toEqual("0-1"); // xadd
                expect(result[1]).toEqual(expectedXinfoStreamResult);
                expect(result[2]).toEqual(expectedXinfoStreamFullResult);
            }

            client.close();
        },
        TIMEOUT,
    );

    runBaseTests<Context>({
        init: async (protocol, clientName?) => {
            const options = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            options.protocol = protocol;
            options.clientName = clientName;
            testsFailed += 1;
            client = await GlideClient.createClient(options);
            return { client, context: { client }, cluster };
        },
        close: (context: Context, testSucceeded: boolean) => {
            if (testSucceeded) {
                testsFailed -= 1;
            }
        },
        timeout: TIMEOUT,
    });
});
