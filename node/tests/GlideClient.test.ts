/**
 * Copyright Valkey GLIDE Project Contributors - SPDX Identifier: Apache-2.0
 */

import {
    afterAll,
    afterEach,
    beforeAll,
    describe,
    expect,
    it,
} from "@jest/globals";
import { BufferReader, BufferWriter } from "protobufjs";
import { v4 as uuidv4 } from "uuid";
import {
    convertGlideRecordToRecord,
    Decoder,
    FlushMode,
    FunctionRestorePolicy,
    GlideClient,
    GlideRecord,
    GlideString,
    ProtocolVersion,
    RequestError,
    Script,
    Transaction,
} from "..";
import { ValkeyCluster } from "../../utils/TestUtils.js";
import { command_request } from "../src/ProtobufMessage";
import { runBaseTests } from "./SharedTests";
import {
    checkFunctionListResponse,
    checkFunctionStatsResponse,
    convertStringArrayToBuffer,
    createLongRunningLuaScript,
    createLuaLibWithLongRunningFunction,
    encodableTransactionTest,
    flushAndCloseClient,
    generateLuaLibCode,
    getClientConfigurationOption,
    getServerVersion,
    parseCommandLineArgs,
    parseEndpoints,
    transactionTest,
    validateTransactionResponse,
    waitForNotBusy,
    waitForScriptNotBusy,
} from "./TestUtilities";

const TIMEOUT = 50000;

describe("GlideClient", () => {
    let testsFailed = 0;
    let cluster: ValkeyCluster;
    let client: GlideClient;
    beforeAll(async () => {
        const standaloneAddresses =
            parseCommandLineArgs()["standalone-endpoints"];
        cluster = standaloneAddresses
            ? await ValkeyCluster.initFromExistingCluster(
                  false,
                  parseEndpoints(standaloneAddresses),
                  getServerVersion,
              )
            : await ValkeyCluster.createCluster(false, 1, 1, getServerVersion);
    }, 20000);

    afterEach(async () => {
        await flushAndCloseClient(false, cluster.getAddresses(), client);
    });

    afterAll(async () => {
        if (testsFailed === 0) {
            await cluster.close();
        }
    }, TIMEOUT);

    it("test protobuf encode/decode delimited", () => {
        // This test is required in order to verify that the autogenerated protobuf
        // files has been corrected and the encoding/decoding works as expected.
        // See "Manually compile protobuf files" in node/README.md to get more info about the fix.
        const writer = new BufferWriter();
        const request = {
            callbackIdx: 1,
            singleCommand: {
                requestType: 2,
                argsArray: command_request.Command.ArgsArray.create({
                    args: convertStringArrayToBuffer(["bar1", "bar2"]),
                }),
            },
        };
        const request2 = {
            callbackIdx: 3,
            singleCommand: {
                requestType: 4,
                argsArray: command_request.Command.ArgsArray.create({
                    args: convertStringArrayToBuffer(["bar3", "bar4"]),
                }),
            },
        };
        command_request.CommandRequest.encodeDelimited(request, writer);
        command_request.CommandRequest.encodeDelimited(request2, writer);
        const buffer = writer.finish();
        const reader = new BufferReader(buffer);

        const dec_msg1 = command_request.CommandRequest.decodeDelimited(reader);
        expect(dec_msg1.callbackIdx).toEqual(1);
        expect(dec_msg1.singleCommand?.requestType).toEqual(2);
        expect(dec_msg1.singleCommand?.argsArray?.args).toEqual(
            convertStringArrayToBuffer(["bar1", "bar2"]),
        );

        const dec_msg2 = command_request.CommandRequest.decodeDelimited(reader);
        expect(dec_msg2.callbackIdx).toEqual(3);
        expect(dec_msg2.singleCommand?.requestType).toEqual(4);
        expect(dec_msg2.singleCommand?.argsArray?.args).toEqual(
            convertStringArrayToBuffer(["bar3", "bar4"]),
        );
    });

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "info without parameters",
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const result = await client.info();
            expect(result).toEqual(expect.stringContaining("# Server"));
            expect(result).toEqual(expect.stringContaining("# Replication"));
            expect(result).toEqual(
                expect.not.stringContaining("# Latencystats"),
            );
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "select dbsize flushdb test %p",
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            expect(await client.select(0)).toEqual("OK");

            const key = uuidv4();
            const value = uuidv4();
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.select(1)).toEqual("OK");
            expect(await client.get(key)).toEqual(null);
            expect(await client.flushdb()).toEqual("OK");
            expect(await client.dbsize()).toEqual(0);

            expect(await client.select(0)).toEqual("OK");
            expect(await client.get(key)).toEqual(value);

            expect(await client.dbsize()).toBeGreaterThan(0);
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");
            expect(await client.dbsize()).toEqual(0);
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "bytes decoder client test %p",
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.Bytes;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");

            const key = uuidv4();
            const value = uuidv4();
            const valueEncoded = Buffer.from(value);
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.get(key)).toEqual(valueEncoded);
            expect(await client.get(key, { decoder: Decoder.String })).toEqual(
                value,
            );
            expect(await client.get(key, { decoder: Decoder.Bytes })).toEqual(
                valueEncoded,
            );
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "string decoder client test %p",
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.String;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");

            const key = uuidv4();
            const value = uuidv4();
            const valueEncoded = Buffer.from(value);
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.get(key)).toEqual(value);
            expect(await client.get(key, { decoder: Decoder.String })).toEqual(
                value,
            );
            expect(await client.get(key, { decoder: Decoder.Bytes })).toEqual(
                valueEncoded,
            );
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        `can send transactions_%p`,
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const transaction = new Transaction();
            const expectedRes = await transactionTest(
                transaction,
                cluster.getVersion(),
            );
            transaction.select(0);
            const result = await client.exec(transaction);
            expectedRes.push(["select(0)", "OK"]);

            validateTransactionResponse(result, expectedRes);
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        `dump and restore transactions_%p`,
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const key1 = uuidv4();
            const key2 = uuidv4();
            const value = uuidv4();

            const transaction1 = new Transaction().set(key1, value).dump(key1);

            // Since DUMP gets binary results, we cannot use the string decoder here, so we expected to get an error.
            await expect(
                client.exec(transaction1, { decoder: Decoder.String }),
            ).rejects.toThrow("invalid utf-8 sequence of");

            const result = await client.exec(transaction1, {
                decoder: Decoder.Bytes,
            });
            expect(result?.[0]).toEqual("OK");
            const dump = result?.[1] as Buffer;

            const transaction2 = new Transaction().restore(key2, 0, dump);
            expect(await client.exec(transaction2)).toEqual(["OK"]);

            expect(value).toEqual(await client.get(key2));

            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        `can send transaction with default string decoder_%p`,
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.String;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");
            const transaction = new Transaction();
            const expectedRes = await encodableTransactionTest(
                transaction,
                "value",
            );
            transaction.select(0);
            const result = await client.exec(transaction);
            expectedRes.push(["select(0)", "OK"]);

            validateTransactionResponse(result, expectedRes);
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        `can send transaction with default bytes decoder_%p`,
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.Bytes;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");
            const transaction = new Transaction();
            const valueEncoded = Buffer.from("value");
            const expectedRes = await encodableTransactionTest(
                transaction,
                valueEncoded,
            );
            transaction.select(0);
            const result = await client.exec(transaction);
            expectedRes.push(["select(0)", "OK"]);

            validateTransactionResponse(result, expectedRes);
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "can return null on WATCH transaction failures",
        async (protocol) => {
            const client1 = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const client2 = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const transaction = new Transaction();
            transaction.get("key");
            const result1 = await client1.watch(["key"]);
            expect(result1).toEqual("OK");

            const result2 = await client2.set("key", "foo");
            expect(result2).toEqual("OK");

            const result3 = await client1.exec(transaction);
            expect(result3).toBeNull();

            client1.close();
            client2.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "object freq transaction test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();
            const maxmemoryPolicyKey = "maxmemory-policy";
            const config = await client.configGet([maxmemoryPolicyKey]);
            const maxmemoryPolicy = config[maxmemoryPolicyKey];

            try {
                const transaction = new Transaction();
                transaction.configSet({
                    [maxmemoryPolicyKey]: "allkeys-lfu",
                });
                transaction.set(key, "foo");
                transaction.objectFreq(key);

                const response = await client.exec(transaction);
                expect(response).not.toBeNull();

                if (response != null) {
                    expect(response.length).toEqual(3);
                    expect(response[0]).toEqual("OK");
                    expect(response[1]).toEqual("OK");
                    expect(response[2]).toBeGreaterThanOrEqual(0);
                }
            } finally {
                expect(
                    await client.configSet({
                        [maxmemoryPolicyKey]: maxmemoryPolicy,
                    }),
                ).toEqual("OK");
            }

            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "object idletime transaction test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();
            const maxmemoryPolicyKey = "maxmemory-policy";
            const config = await client.configGet([maxmemoryPolicyKey]);
            const maxmemoryPolicy = config[maxmemoryPolicyKey];

            try {
                const transaction = new Transaction();
                transaction.configSet({
                    // OBJECT IDLETIME requires a non-LFU maxmemory-policy
                    [maxmemoryPolicyKey]: "allkeys-random",
                });
                transaction.set(key, "foo");
                transaction.objectIdletime(key);

                const response = await client.exec(transaction);
                expect(response).not.toBeNull();

                if (response != null) {
                    expect(response.length).toEqual(3);
                    // transaction.configSet({[maxmemoryPolicyKey]: "allkeys-random"});
                    expect(response[0]).toEqual("OK");
                    // transaction.set(key, "foo");
                    expect(response[1]).toEqual("OK");
                    // transaction.objectIdletime(key);
                    expect(response[2]).toBeGreaterThanOrEqual(0);
                }
            } finally {
                expect(
                    await client.configSet({
                        [maxmemoryPolicyKey]: maxmemoryPolicy,
                    }),
                ).toEqual("OK");
            }

            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "object refcount transaction test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();
            const transaction = new Transaction();
            transaction.set(key, "foo");
            transaction.objectRefcount(key);

            const response = await client.exec(transaction);
            expect(response).not.toBeNull();

            if (response != null) {
                expect(response.length).toEqual(2);
                expect(response[0]).toEqual("OK"); // transaction.set(key, "foo");
                expect(response[1]).toBeGreaterThanOrEqual(1); // transaction.objectRefcount(key);
            }

            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "lolwut test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const result = await client.lolwut();
            expect(result).toEqual(expect.stringContaining("Redis ver. "));

            const result2 = await client.lolwut({ parameters: [] });
            expect(result2).toEqual(expect.stringContaining("Redis ver. "));

            const result3 = await client.lolwut({ parameters: [50, 20] });
            expect(result3).toEqual(expect.stringContaining("Redis ver. "));

            const result4 = await client.lolwut({ version: 6 });
            expect(result4).toEqual(expect.stringContaining("Redis ver. "));

            const result5 = await client.lolwut({
                version: 5,
                parameters: [30, 4, 4],
            });
            expect(result5).toEqual(expect.stringContaining("Redis ver. "));

            // transaction tests
            const transaction = new Transaction();
            transaction.lolwut();
            transaction.lolwut({ version: 5 });
            transaction.lolwut({ parameters: [1, 2] });
            transaction.lolwut({ version: 6, parameters: [42] });
            const results = await client.exec(transaction);

            if (results) {
                for (const element of results) {
                    expect(element).toEqual(
                        expect.stringContaining("Redis ver. "),
                    );
                }
            } else {
                throw new Error("Invalid LOLWUT transaction test results.");
            }

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "copy with DB test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("6.2.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const source = `{key}-${uuidv4()}`;
            const destination = `{key}-${uuidv4()}`;
            const value1 = uuidv4();
            const value2 = uuidv4();
            const index0 = 0;
            const index1 = 1;
            const index2 = 2;

            // neither key exists
            expect(
                await client.copy(source, destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(false);

            // source exists, destination does not
            expect(await client.set(source, value1)).toEqual("OK");
            expect(
                await client.copy(source, destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(true);
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value1);

            // new value for source key
            expect(await client.select(index0)).toEqual("OK");
            expect(await client.set(source, value2)).toEqual("OK");

            // no REPLACE, copying to existing key on DB 1, non-existing key on DB 2
            expect(
                await client.copy(Buffer.from(source), destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(false);
            expect(
                await client.copy(source, Buffer.from(destination), {
                    destinationDB: index2,
                    replace: false,
                }),
            ).toEqual(true);

            // new value only gets copied to DB 2
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value1);
            expect(await client.select(index2)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value2);

            // both exists, with REPLACE, when value isn't the same, source always get copied to
            // destination
            expect(await client.select(index0)).toEqual("OK");
            expect(
                await client.copy(
                    Buffer.from(source),
                    Buffer.from(destination),
                    {
                        destinationDB: index1,
                        replace: true,
                    },
                ),
            ).toEqual(true);
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value2);

            //transaction tests
            const transaction = new Transaction();
            transaction.select(index1);
            transaction.set(source, value1);
            transaction.copy(source, destination, {
                destinationDB: index1,
                replace: true,
            });
            transaction.get(destination);
            const results = await client.exec(transaction);

            expect(results).toEqual(["OK", "OK", true, value1]);

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "move test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + uuidv4();
            const key2 = "{key}-2" + uuidv4();
            const value = uuidv4();

            expect(await client.select(0)).toEqual("OK");
            expect(await client.move(key1, 1)).toEqual(false);

            expect(await client.set(key1, value)).toEqual("OK");
            expect(await client.get(key1)).toEqual(value);
            expect(await client.move(Buffer.from(key1), 1)).toEqual(true);
            expect(await client.get(key1)).toEqual(null);
            expect(await client.select(1)).toEqual("OK");
            expect(await client.get(key1)).toEqual(value);

            await expect(client.move(key1, -1)).rejects.toThrow(RequestError);

            //transaction tests
            const transaction = new Transaction();
            transaction.select(1);
            transaction.move(key2, 0);
            transaction.set(key2, value);
            transaction.move(key2, 0);
            transaction.select(0);
            transaction.get(key2);
            const results = await client.exec(transaction);

            expect(results).toEqual(["OK", false, "OK", true, "OK", value]);

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function load function list function stats test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + uuidv4().replaceAll("-", "");
                const funcName = "myfunc1c" + uuidv4().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(Buffer.from(code))).toEqual(
                    libName,
                );

                expect(
                    await client.fcall(
                        Buffer.from(funcName),
                        [],
                        [Buffer.from("one"), "two"],
                        { decoder: Decoder.Bytes },
                    ),
                ).toEqual(Buffer.from("one"));
                expect(
                    await client.fcallReadonly(
                        Buffer.from(funcName),
                        [],
                        ["one", Buffer.from("two")],
                        { decoder: Decoder.Bytes },
                    ),
                ).toEqual(Buffer.from("one"));

                let functionStats = await client.functionStats();

                for (const response of Object.values(functionStats)) {
                    checkFunctionStatsResponse(response, [], 1, 1);
                }

                let functionList = await client.functionList({
                    libNamePattern: Buffer.from(libName),
                    decoder: Decoder.Bytes,
                });
                let expectedDescription = new Map<string, GlideString | null>([
                    [funcName, null],
                ]);
                let expectedFlags = new Map<string, GlideString[]>([
                    [funcName, [Buffer.from("no-writes")]],
                ]);

                checkFunctionListResponse(
                    functionList,
                    Buffer.from(libName),
                    expectedDescription,
                    expectedFlags,
                );

                // re-load library without replace
                await expect(client.functionLoad(code)).rejects.toThrow(
                    `Library '${libName}' already exists`,
                );

                // re-load library with replace
                expect(
                    await client.functionLoad(code, {
                        replace: true,
                        decoder: Decoder.Bytes,
                    }),
                ).toEqual(Buffer.from(libName));

                // overwrite lib with new code
                const func2Name = "myfunc2c" + uuidv4().replaceAll("-", "");
                const newCode = generateLuaLibCode(
                    libName,
                    new Map([
                        [funcName, "return args[1]"],
                        [func2Name, "return #args"],
                    ]),
                    true,
                );
                expect(
                    await client.functionLoad(newCode, { replace: true }),
                ).toEqual(libName);

                functionList = await client.functionList({ withCode: true });
                expectedDescription = new Map<string, string | null>([
                    [funcName, null],
                    [func2Name, null],
                ]);
                expectedFlags = new Map<string, string[]>([
                    [funcName, ["no-writes"]],
                    [func2Name, ["no-writes"]],
                ]);

                checkFunctionListResponse(
                    functionList,
                    libName,
                    expectedDescription,
                    expectedFlags,
                    newCode,
                );

                functionStats = await client.functionStats({
                    decoder: Decoder.Bytes,
                });

                for (const response of Object.values(functionStats)) {
                    checkFunctionStatsResponse(response, [], 1, 2);
                }

                expect(
                    await client.fcall(func2Name, [], ["one", "two"]),
                ).toEqual(2);
                expect(
                    await client.fcallReadonly(func2Name, [], ["one", "two"]),
                ).toEqual(2);
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                const functionStats = await client.functionStats();

                for (const response of Object.values(functionStats)) {
                    checkFunctionStatsResponse(response, [], 0, 0);
                }

                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function flush test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + uuidv4().replaceAll("-", "");
                const funcName = "myfunc1c" + uuidv4().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(code)).toEqual(libName);

                // Flush functions
                expect(await client.functionFlush(FlushMode.SYNC)).toEqual(
                    "OK",
                );
                expect(await client.functionFlush(FlushMode.ASYNC)).toEqual(
                    "OK",
                );

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                // Attempt to re-load library without overwriting to ensure FLUSH was effective
                expect(await client.functionLoad(code)).toEqual(libName);
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function delete test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + uuidv4().replaceAll("-", "");
                const funcName = "myfunc1c" + uuidv4().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );
                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(code)).toEqual(libName);

                // Delete the function
                expect(await client.functionDelete(libName)).toEqual("OK");

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                // deleting a non-existing library
                await expect(client.functionDelete(libName)).rejects.toThrow(
                    `Library not found`,
                );
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function kill RO func %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { requestTimeout: 10000 },
            );
            const client = await GlideClient.createClient(config);
            const testClient = await GlideClient.createClient(config);

            try {
                const libName = "function_kill_no_write";
                const funcName = "deadlock_no_write";
                const code = createLuaLibWithLongRunningFunction(
                    libName,
                    funcName,
                    6,
                    true,
                );
                expect(await client.functionFlush()).toEqual("OK");
                // nothing to kill
                await expect(client.functionKill()).rejects.toThrow(/notbusy/i);

                // load the lib
                expect(
                    await client.functionLoad(code, { replace: true }),
                ).toEqual(libName);

                try {
                    // call the function without await
                    const promise = testClient
                        .fcall(funcName, [], [])
                        .catch((e) =>
                            expect((e as Error).message).toContain(
                                "Script killed",
                            ),
                        );

                    let killed = false;
                    let timeout = 4000;
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    while (timeout >= 0) {
                        try {
                            expect(await client.functionKill()).toEqual("OK");
                            killed = true;
                            break;
                        } catch {
                            // do nothing
                        }

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );
                        timeout -= 500;
                    }

                    expect(killed).toBeTruthy();
                    await promise;
                } finally {
                    await waitForNotBusy(client);
                }
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                testClient.close();
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function kill RW func %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { requestTimeout: 10000 },
            );
            const client = await GlideClient.createClient(config);
            const testClient = await GlideClient.createClient(config);

            try {
                const libName = "function_kill_write";
                const key = libName;
                const funcName = "deadlock_write";
                const code = createLuaLibWithLongRunningFunction(
                    libName,
                    funcName,
                    6,
                    false,
                );
                expect(await client.functionFlush()).toEqual("OK");
                // nothing to kill
                await expect(client.functionKill()).rejects.toThrow(/notbusy/i);

                // load the lib
                expect(
                    await client.functionLoad(code, { replace: true }),
                ).toEqual(libName);

                let promise = null;

                try {
                    // call the function without await
                    promise = testClient.fcall(funcName, [key], []);

                    let foundUnkillable = false;
                    let timeout = 4000;
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    while (timeout >= 0) {
                        try {
                            // valkey kills a function with 5 sec delay
                            // but this will always throw an error in the test
                            await client.functionKill();
                        } catch (err) {
                            // looking for an error with "unkillable" in the message
                            // at that point we can break the loop
                            if (
                                (err as Error).message
                                    .toLowerCase()
                                    .includes("unkillable")
                            ) {
                                foundUnkillable = true;
                                break;
                            }
                        }

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );
                        timeout -= 500;
                    }

                    expect(foundUnkillable).toBeTruthy();
                } finally {
                    // If function wasn't killed, and it didn't time out - it blocks the server and cause rest
                    // test to fail. Wait for the function to complete (we cannot kill it)
                    expect(await promise).toContain("Timed out");
                }
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                testClient.close();
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function dump function restore %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            const client = await GlideClient.createClient(config);
            expect(await client.functionFlush()).toEqual("OK");

            try {
                // dumping an empty lib
                expect(
                    (await client.functionDump()).byteLength,
                ).toBeGreaterThan(0);

                const name1 = "Foster";
                const name2 = "Dogster";
                // function $name1 returns first argument
                // function $name2 returns argument array len
                let code = generateLuaLibCode(
                    name1,
                    new Map([
                        [name1, "return args[1]"],
                        [name2, "return #args"],
                    ]),
                    false,
                );
                expect(await client.functionLoad(code)).toEqual(name1);

                const flist = await client.functionList({ withCode: true });
                const dump = await client.functionDump();

                // restore without cleaning the lib and/or overwrite option causes an error
                await expect(client.functionRestore(dump)).rejects.toThrow(
                    `Library ${name1} already exists`,
                );

                // APPEND policy also fails for the same reason (name collision)
                await expect(
                    client.functionRestore(dump, FunctionRestorePolicy.APPEND),
                ).rejects.toThrow(`Library ${name1} already exists`);

                // REPLACE policy succeeds
                expect(
                    await client.functionRestore(
                        dump,
                        FunctionRestorePolicy.REPLACE,
                    ),
                ).toEqual("OK");
                // but nothing changed - all code overwritten
                expect(await client.functionList({ withCode: true })).toEqual(
                    flist,
                );

                // create lib with another name, but with the same function names
                expect(await client.functionFlush(FlushMode.SYNC)).toEqual(
                    "OK",
                );
                code = generateLuaLibCode(
                    name2,
                    new Map([
                        [name1, "return args[1]"],
                        [name2, "return #args"],
                    ]),
                    false,
                );
                expect(await client.functionLoad(code)).toEqual(name2);

                // REPLACE policy now fails due to a name collision
                await expect(client.functionRestore(dump)).rejects.toThrow(
                    new RegExp(`Function ${name1}|${name2} already exists`),
                );

                // FLUSH policy succeeds, but deletes the second lib
                expect(
                    await client.functionRestore(
                        dump,
                        FunctionRestorePolicy.FLUSH,
                    ),
                ).toEqual("OK");
                expect(await client.functionList({ withCode: true })).toEqual(
                    flist,
                );

                // call restored functions
                expect(await client.fcall(name1, [], ["meow", "woem"])).toEqual(
                    "meow",
                );
                expect(await client.fcall(name2, [], ["meow", "woem"])).toEqual(
                    2,
                );
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function dump function restore in transaction %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            const client = await GlideClient.createClient(config);
            expect(await client.functionFlush()).toEqual("OK");

            try {
                const name1 = "Foster";
                const name2 = "Dogster";
                // function returns first argument
                const code = generateLuaLibCode(
                    name1,
                    new Map([[name2, "return args[1]"]]),
                    false,
                );
                expect(await client.functionLoad(code)).toEqual(name1);

                // Verify functionDump
                let transaction = new Transaction().functionDump();
                const result = await client.exec(transaction, {
                    decoder: Decoder.Bytes,
                });
                const data = result?.[0] as Buffer;

                // Verify functionRestore
                transaction = new Transaction()
                    .functionRestore(data, FunctionRestorePolicy.REPLACE)
                    .fcall(name2, [], ["meow"]);
                expect(await client.exec(transaction)).toEqual(["OK", "meow"]);
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "randomKey test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();

            // setup: delete all keys in DB 0 and DB 1
            expect(await client.select(0)).toEqual("OK");
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");
            expect(await client.select(1)).toEqual("OK");
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");

            // no keys exist so randomKey returns null
            expect(await client.randomKey()).toBeNull();
            // set `key` in DB 1
            expect(await client.set(key, "foo")).toEqual("OK");
            // `key` should be the only key in the database
            expect(await client.randomKey()).toEqual(key);
            // test binary decoder
            expect(await client.randomKey({ decoder: Decoder.Bytes })).toEqual(
                Buffer.from(key),
            );

            // switch back to DB 0
            expect(await client.select(0)).toEqual("OK");
            // DB 0 should still have no keys, so randomKey should still return null
            expect(await client.randomKey()).toBeNull();

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "watch test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + uuidv4();
            const key2 = "{key}-2" + uuidv4();
            const key3 = "{key}-3" + uuidv4();
            const key4 = "{key}-4" + uuidv4();
            const setFoobarTransaction = new Transaction();
            const setHelloTransaction = new Transaction();

            // Returns null when a watched key is modified before it is executed in a transaction command.
            // Transaction commands are not performed.
            expect(await client.watch([key1, key2, key3])).toEqual("OK");
            expect(await client.set(key2, "hello")).toEqual("OK");
            setFoobarTransaction
                .set(key1, "foobar")
                .set(key2, "foobar")
                .set(key3, "foobar");
            let results = await client.exec(setFoobarTransaction);
            expect(results).toEqual(null);
            // sanity check
            expect(await client.get(key1)).toEqual(null);
            expect(await client.get(key2)).toEqual("hello");
            expect(await client.get(key3)).toEqual(null);

            // Transaction executes command successfully with a read command on the watch key before
            // transaction is executed.
            expect(await client.watch([key1, key2, key3])).toEqual("OK");
            expect(await client.get(key2)).toEqual("hello");
            results = await client.exec(setFoobarTransaction);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");
            expect(await client.get(key3)).toEqual("foobar");

            // Transaction executes command successfully with unmodified watched keys
            expect(await client.watch([key1, Buffer.from(key2), key3])).toEqual(
                "OK",
            );
            results = await client.exec(setFoobarTransaction);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");
            expect(await client.get(key3)).toEqual("foobar");

            // Transaction executes command successfully with a modified watched key but is not in the
            // transaction.
            expect(await client.watch([key4])).toEqual("OK");
            setHelloTransaction
                .set(key1, "hello")
                .set(key2, "hello")
                .set(key3, "hello");
            results = await client.exec(setHelloTransaction);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("hello");
            expect(await client.get(key2)).toEqual("hello");
            expect(await client.get(key3)).toEqual("hello");

            // WATCH can not have an empty String array parameter
            await expect(client.watch([])).rejects.toThrow(RequestError);

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "unwatch test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + uuidv4();
            const key2 = "{key}-2" + uuidv4();

            const setFoobarTransaction = new Transaction();

            // UNWATCH returns OK when there no watched keys
            expect(await client.unwatch()).toEqual("OK");

            // Transaction executes successfully after modifying a watched key then calling UNWATCH
            expect(await client.watch([key1, key2])).toEqual("OK");
            expect(await client.set(key2, "hello")).toEqual("OK");
            expect(await client.unwatch()).toEqual("OK");
            setFoobarTransaction.set(key1, "foobar").set(key2, "foobar");
            const results = await client.exec(setFoobarTransaction);
            expect(results).toEqual(["OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "xinfo stream transaction test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = uuidv4();

            const transaction = new Transaction();
            transaction.xadd(key, [["field1", "value1"]], { id: "0-1" });
            transaction.xinfoStream(key);
            transaction.xinfoStream(key, true);
            const result = await client.exec(transaction);
            expect(result).not.toBeNull();

            const versionLessThan7 =
                cluster.checkIfServerVersionLessThan("7.0.0");

            const expectedXinfoStreamResult = {
                length: 1,
                "radix-tree-keys": 1,
                "radix-tree-nodes": 2,
                "last-generated-id": "0-1",
                groups: 0,
                "first-entry": ["0-1", ["field1", "value1"]],
                "last-entry": ["0-1", ["field1", "value1"]],
                "max-deleted-entry-id": versionLessThan7 ? undefined : "0-0",
                "entries-added": versionLessThan7 ? undefined : 1,
                "recorded-first-entry-id": versionLessThan7 ? undefined : "0-1",
            };

            const expectedXinfoStreamFullResult = {
                length: 1,
                "radix-tree-keys": 1,
                "radix-tree-nodes": 2,
                "last-generated-id": "0-1",
                entries: [["0-1", ["field1", "value1"]]],
                groups: [],
                "max-deleted-entry-id": versionLessThan7 ? undefined : "0-0",
                "entries-added": versionLessThan7 ? undefined : 1,
                "recorded-first-entry-id": versionLessThan7 ? undefined : "0-1",
            };

            if (result != null) {
                expect(result[0]).toEqual("0-1"); // xadd
                const res1 = convertGlideRecordToRecord(
                    result[1] as GlideRecord<[GlideString, GlideString][]>,
                );
                const res2 = convertGlideRecordToRecord(
                    result[2] as GlideRecord<[GlideString, GlideString][]>,
                );
                expect(res1).toEqual(expectedXinfoStreamResult);
                expect(res2).toEqual(expectedXinfoStreamFullResult);
            }

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "script kill unkillable test_%p",
        async (protocol) => {
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { requestTimeout: 10000 },
            );
            const client1 = await GlideClient.createClient(config);
            const client2 = await GlideClient.createClient(config);

            // Verify that script kill raises an error when no script is running
            await expect(client1.scriptKill()).rejects.toThrow(
                "No scripts in execution right now",
            );

            // Create a long-running script
            const longScript = new Script(createLongRunningLuaScript(5, true));
            let promise = null;

            try {
                // call the script without await
                promise = client2.invokeScript(longScript, {
                    keys: ["{key}-" + uuidv4()],
                });

                let foundUnkillable = false;
                let timeout = 4000;
                await new Promise((resolve) => setTimeout(resolve, 1000));

                while (timeout >= 0) {
                    try {
                        // keep trying to kill until we get an "OK"
                        await client1.scriptKill();
                    } catch (err) {
                        // a RequestError may occur if the script is not yet running
                        // sleep and try again
                        if (
                            (err as Error).message
                                .toLowerCase()
                                .includes("unkillable")
                        ) {
                            foundUnkillable = true;
                            break;
                        }
                    }

                    await new Promise((resolve) => setTimeout(resolve, 500));
                    timeout -= 500;
                }

                expect(foundUnkillable).toBeTruthy();
            } finally {
                // If script wasn't killed, and it didn't time out - it blocks the server and cause the
                // test to fail. Wait for the script to complete (we cannot kill it)
                expect(await promise).toContain("Timed out");
                client1.close();
                client2.close();
            }
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "script kill killable test_%p",
        async (protocol) => {
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { requestTimeout: 10000 },
            );
            const client1 = await GlideClient.createClient(config);
            const client2 = await GlideClient.createClient(config);

            try {
                // Verify that script kill raises an error when no script is running
                await expect(client1.scriptKill()).rejects.toThrow(
                    "No scripts in execution right now",
                );

                // Create a long-running script
                const longScript = new Script(
                    createLongRunningLuaScript(5, false),
                );

                try {
                    // call the script without await
                    const promise = client2
                        .invokeScript(longScript)
                        .catch((e) =>
                            expect((e as Error).message).toContain(
                                "Script killed",
                            ),
                        );

                    let killed = false;
                    let timeout = 4000;
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    while (timeout >= 0) {
                        try {
                            expect(await client1.scriptKill()).toEqual("OK");
                            killed = true;
                            break;
                        } catch {
                            // do nothing
                        }

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );
                        timeout -= 500;
                    }

                    expect(killed).toBeTruthy();
                    await promise;
                } finally {
                    await waitForScriptNotBusy(client1);
                }
            } finally {
                expect(await client1.scriptFlush()).toEqual("OK");
                client1.close();
                client2.close();
            }
        },
    );

    it.each([
        [ProtocolVersion.RESP2, 5],
        [ProtocolVersion.RESP2, 100],
        [ProtocolVersion.RESP2, 1500],
        [ProtocolVersion.RESP3, 5],
        [ProtocolVersion.RESP3, 100],
        [ProtocolVersion.RESP3, 1500],
    ])(
        "test inflight requests limit of %p with protocol %p",
        async (protocol, inflightRequestsLimit) => {
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { inflightRequestsLimit },
            );
            const client = await GlideClient.createClient(config);

            try {
                const key1 = `{nonexistinglist}:1-${uuidv4()}`;
                const tasks: Promise<[GlideString, GlideString] | null>[] = [];

                // Start inflightRequestsLimit blocking tasks
                for (let i = 0; i < inflightRequestsLimit; i++) {
                    tasks.push(client.blpop([key1], 0));
                }

                // This task should immediately fail due to reaching the limit
                await expect(client.blpop([key1], 0)).rejects.toThrow(
                    RequestError,
                );

                // Verify that all previous tasks are still pending
                const timeoutPromise = new Promise((resolve) =>
                    setTimeout(resolve, 100),
                );
                const allTasksStatus = await Promise.race([
                    Promise.any(
                        tasks.map((task) => task.then(() => "resolved")),
                    ),
                    timeoutPromise.then(() => "pending"),
                ]);
                expect(allTasksStatus).toBe("pending");
            } finally {
                await client.close();
            }
        },
    );

    runBaseTests({
        init: async (protocol, configOverrides) => {
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                configOverrides,
            );

            testsFailed += 1;
            client = await GlideClient.createClient(config);
            return { client, cluster };
        },
        close: (testSucceeded: boolean) => {
            if (testSucceeded) {
                testsFailed -= 1;
            }
        },
        timeout: TIMEOUT,
    });
});
