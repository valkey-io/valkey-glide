/**
 * Copyright Valkey GLIDE Project Contributors - SPDX Identifier: Apache-2.0
 */

import {
    afterAll,
    afterEach,
    beforeAll,
    describe,
    expect,
    it,
} from "@jest/globals";
import { BufferReader, BufferWriter } from "protobufjs/minimal";
import { ValkeyCluster } from "../../utils/TestUtils.js";
import {
    Batch,
    Decoder,
    FlushMode,
    FunctionRestorePolicy,
    GlideClient,
    GlideRecord,
    GlideString,
    ListDirection,
    ProtocolVersion,
    RequestError,
    Script,
    convertGlideRecordToRecord,
} from "../build-ts";
import { command_request } from "../build-ts/ProtobufMessage";
import { runBaseTests } from "./SharedTests";
import {
    batchTest,
    checkFunctionListResponse,
    checkFunctionStatsResponse,
    convertStringArrayToBuffer,
    createLongRunningLuaScript,
    createLuaLibWithLongRunningFunction,
    encodableBatchTest,
    flushAndCloseClient,
    generateLuaLibCode,
    getClientConfigurationOption,
    getRandomKey,
    getServerVersion,
    parseEndpoints,
    validateBatchResponse,
    waitForNotBusy,
} from "./TestUtilities";
// This timeout is used for tests like transactions and copy with DB, it should not be used for other tests
const TIMEOUT = 50000;

// This timeout is used for functions tests, it should not be used for other tests
const FUNCTION_TIMEOUT = 6000;

// This timeout is used for cleanup operations like closing clients
const CLEANUP_TIMEOUT = 10000;

describe("GlideClient", () => {
    let testsFailed = 0;
    let cluster: ValkeyCluster;
    let azCluster: ValkeyCluster;
    let client: GlideClient;
    let azClient: GlideClient;
    beforeAll(async () => {
        const standaloneAddresses: string =
            global.STAND_ALONE_ENDPOINT as string;
        cluster = standaloneAddresses
            ? await ValkeyCluster.initFromExistingCluster(
                  false,
                  parseEndpoints(standaloneAddresses),
                  getServerVersion,
              )
            : await ValkeyCluster.createCluster(false, 1, 1, getServerVersion);

        // Add small delay between cluster initializations to prevent socket contention
        await new Promise((resolve) => setTimeout(resolve, 100));

        azCluster = standaloneAddresses
            ? await ValkeyCluster.initFromExistingCluster(
                  false,
                  parseEndpoints(standaloneAddresses),
                  getServerVersion,
              )
            : await ValkeyCluster.createCluster(false, 1, 1, getServerVersion);
    }, 20000);

    afterEach(async () => {
        await flushAndCloseClient(false, cluster?.getAddresses(), client);
        // Add small delay between cluster cleanups to prevent socket exhaustion
        await new Promise((resolve) => setTimeout(resolve, 5));
        await flushAndCloseClient(false, azCluster?.getAddresses(), azClient);
    });

    afterAll(async () => {
        if (testsFailed === 0) {
            await cluster.close();
            // Add small delay between cluster closures to prevent socket contention
            await new Promise((resolve) => setTimeout(resolve, 50));
            await azCluster.close();
        } else {
            await cluster.close(true);
            // Add small delay between cluster closures to prevent socket contention
            await new Promise((resolve) => setTimeout(resolve, 50));
            await azCluster.close();
        }
    }, CLEANUP_TIMEOUT);

    it("test protobuf encode/decode delimited", () => {
        // This test is required in order to verify that the autogenerated protobuf
        // files has been corrected and the encoding/decoding works as expected.
        // See "Manually compile protobuf files" in node/README.md to get more info about the fix.
        const writer = new BufferWriter();
        const request = {
            callbackIdx: 1,
            singleCommand: {
                requestType: 2,
                argsArray: command_request.Command.ArgsArray.create({
                    args: convertStringArrayToBuffer(["bar1", "bar2"]),
                }),
            },
        };
        const request2 = {
            callbackIdx: 3,
            singleCommand: {
                requestType: 4,
                argsArray: command_request.Command.ArgsArray.create({
                    args: convertStringArrayToBuffer(["bar3", "bar4"]),
                }),
            },
        };
        command_request.CommandRequest.encodeDelimited(request, writer);
        command_request.CommandRequest.encodeDelimited(request2, writer);
        const buffer = writer.finish();
        const reader = new BufferReader(buffer);

        const dec_msg1 = command_request.CommandRequest.decodeDelimited(reader);
        expect(dec_msg1.callbackIdx).toEqual(1);
        expect(dec_msg1.singleCommand?.requestType).toEqual(2);
        expect(dec_msg1.singleCommand?.argsArray?.args).toEqual(
            convertStringArrayToBuffer(["bar1", "bar2"]),
        );

        const dec_msg2 = command_request.CommandRequest.decodeDelimited(reader);
        expect(dec_msg2.callbackIdx).toEqual(3);
        expect(dec_msg2.singleCommand?.requestType).toEqual(4);
        expect(dec_msg2.singleCommand?.argsArray?.args).toEqual(
            convertStringArrayToBuffer(["bar3", "bar4"]),
        );
    });

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "info without parameters",
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const result = await client.info();
            expect(result).toEqual(expect.stringContaining("# Server"));
            expect(result).toEqual(expect.stringContaining("# Replication"));
            expect(result).toEqual(
                expect.not.stringContaining("# Latencystats"),
            );
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "check that blocking commands returns never timeout_%p",
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol, {
                    requestTimeout: 300,
                }),
            );

            const promiseList = [
                client.blmove(
                    "source",
                    "destination",
                    ListDirection.LEFT,
                    ListDirection.LEFT,
                    0.1,
                ),
                client.bzpopmax(["key1", "key2"], 0),
                client.bzpopmin(["key1", "key2"], 0),
            ];

            try {
                for (const promise of promiseList) {
                    const timeoutPromise = new Promise((resolve) => {
                        setTimeout(resolve, 500);
                    });
                    await Promise.race([promise, timeoutPromise]);
                }
            } finally {
                for (const promise of promiseList) {
                    await Promise.resolve([promise]);
                }

                client.close();
            }
        },
        5000,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "select dbsize flushdb test %p",
        async (protocol) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            expect(await client.select(0)).toEqual("OK");

            const key = getRandomKey();
            const value = getRandomKey();
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.select(1)).toEqual("OK");
            expect(await client.get(key)).toEqual(null);
            expect(await client.flushdb()).toEqual("OK");
            expect(await client.dbsize()).toEqual(0);

            expect(await client.select(0)).toEqual("OK");
            expect(await client.get(key)).toEqual(value);

            expect(await client.dbsize()).toBeGreaterThan(0);
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");
            expect(await client.dbsize()).toEqual(0);
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "bytes decoder client test %p",
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.Bytes;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");

            const key = getRandomKey();
            const value = getRandomKey();
            const valueEncoded = Buffer.from(value);
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.get(key)).toEqual(valueEncoded);
            expect(await client.get(key, { decoder: Decoder.String })).toEqual(
                value,
            );
            expect(await client.get(key, { decoder: Decoder.Bytes })).toEqual(
                valueEncoded,
            );
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "string decoder client test %p",
        async (protocol) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.String;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");

            const key = getRandomKey();
            const value = getRandomKey();
            const valueEncoded = Buffer.from(value);
            const result = await client.set(key, value);
            expect(result).toEqual("OK");

            expect(await client.get(key)).toEqual(value);
            expect(await client.get(key, { decoder: Decoder.String })).toEqual(
                value,
            );
            expect(await client.get(key, { decoder: Decoder.Bytes })).toEqual(
                valueEncoded,
            );
            client.close();
        },
    );

    // TODO: currently disabled xpendingWithOptions. Need to fix flakiness.
    describe.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "Protocol is RESP2 = %s",
        (protocol) => {
            describe.each([Decoder.String, Decoder.Bytes])(
                "Decoder String = %s",
                (decoder) => {
                    describe.each([true, false])(
                        "isAtomic = %s",
                        (isAtomic) => {
                            it(
                                "can send batches",
                                async () => {
                                    client = await GlideClient.createClient(
                                        getClientConfigurationOption(
                                            cluster.getAddresses(),
                                            protocol,
                                        ),
                                    );
                                    const batch = new Batch(isAtomic);
                                    const expectedRes = await batchTest(
                                        batch,
                                        cluster,
                                        decoder,
                                    );
                                    batch.select(0);
                                    const result = await client.exec(
                                        batch,
                                        true,
                                        {
                                            decoder: Decoder.String,
                                        },
                                    );
                                    expectedRes.push(["select(0)", "OK"]);

                                    validateBatchResponse(result, expectedRes);
                                    client.close();
                                },
                                TIMEOUT,
                            );
                        },
                    );
                },
            );
        },
    );

    it.each([
        [ProtocolVersion.RESP2, true],
        [ProtocolVersion.RESP2, false],
        [ProtocolVersion.RESP3, true],
        [ProtocolVersion.RESP3, false],
    ])(
        `dump and restore batches_%p with isAtomic=%p`,
        async (protocol, isAtomic) => {
            client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const key1 = getRandomKey();
            const key2 = getRandomKey();
            const value = "value";

            const batch1 = new Batch(isAtomic).set(key1, value).dump(key1);

            // Since DUMP gets binary results, we cannot use the string decoder here, so we expected to get an error.
            await expect(
                client.exec(batch1, true, { decoder: Decoder.String }),
            ).rejects.toThrow(
                /invalid utf-8 sequence|incomplete utf-8 byte sequence/,
            );

            const result = await client.exec(batch1, true, {
                decoder: Decoder.Bytes,
            });
            expect(result?.[0]).toEqual("OK");
            const dump = result?.[1] as Buffer;

            const batch2 = new Batch(isAtomic).restore(key2, 0, dump);
            expect(await client.exec(batch2, true)).toEqual(["OK"]);

            expect(value).toEqual(await client.get(key2));

            client.close();
        },
    );

    it.each([
        [ProtocolVersion.RESP2, true],
        [ProtocolVersion.RESP2, false],
        [ProtocolVersion.RESP3, true],
        [ProtocolVersion.RESP3, false],
    ])(
        `can send batches with default string decoder_%p with isAtomic=%p`,
        async (protocol, isAtomic) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.String;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");
            const batch = new Batch(isAtomic);
            const expectedRes = await encodableBatchTest(batch, "value");
            batch.select(0);
            const result = await client.exec(batch, true);
            expectedRes.push(["select(0)", "OK"]);

            validateBatchResponse(result, expectedRes);
            client.close();
        },
    );

    it.each([
        [ProtocolVersion.RESP2, true],
        [ProtocolVersion.RESP2, false],
        [ProtocolVersion.RESP3, true],
        [ProtocolVersion.RESP3, false],
    ])(
        `can send batch with default bytes decoder_%p with isAtomic=%p`,
        async (protocol, isAtomic) => {
            const clientConfig = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            clientConfig.defaultDecoder = Decoder.Bytes;
            client = await GlideClient.createClient(clientConfig);
            expect(await client.select(0)).toEqual("OK");
            const batch = new Batch(isAtomic);
            const valueEncoded = Buffer.from("value");
            const expectedRes = await encodableBatchTest(batch, valueEncoded);
            batch.select(0);
            const result = await client.exec(batch, true);
            expectedRes.push(["select(0)", "OK"]);

            validateBatchResponse(result, expectedRes);
            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "can return null on WATCH transaction failures",
        async (protocol) => {
            const client1 = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const client2 = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );
            const transaction = new Batch(true);
            transaction.get("key");
            const result1 = await client1.watch(["key"]);
            expect(result1).toEqual("OK");

            const result2 = await client2.set("key", "foo");
            expect(result2).toEqual("OK");

            const result3 = await client1.exec(transaction, true);
            expect(result3).toBeNull();

            client1.close();
            client2.close();
        },
    );

    it.each([
        [ProtocolVersion.RESP2, true],
        [ProtocolVersion.RESP2, false],
        [ProtocolVersion.RESP3, true],
        [ProtocolVersion.RESP3, false],
    ])(
        "object freq batch test_%p with isAtomic=%p",
        async (protocol, isAtomic) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = getRandomKey();
            const maxmemoryPolicyKey = "maxmemory-policy";
            const config = await client.configGet([maxmemoryPolicyKey]);
            const maxmemoryPolicy = config[maxmemoryPolicyKey];

            try {
                const batch = new Batch(isAtomic);
                batch.configSet({
                    [maxmemoryPolicyKey]: "allkeys-lfu",
                });
                batch.set(key, "foo");
                batch.objectFreq(key);

                const response = await client.exec(batch, true);
                expect(response).not.toBeNull();

                if (response != null) {
                    expect(response.length).toEqual(3);
                    expect(response[0]).toEqual("OK");
                    expect(response[1]).toEqual("OK");
                    expect(response[2]).toBeGreaterThanOrEqual(0);
                }
            } finally {
                expect(
                    await client.configSet({
                        [maxmemoryPolicyKey]: maxmemoryPolicy,
                    }),
                ).toEqual("OK");
            }

            client.close();
        },
    );

    it.each([
        [ProtocolVersion.RESP2, true],
        [ProtocolVersion.RESP2, false],
        [ProtocolVersion.RESP3, true],
        [ProtocolVersion.RESP3, false],
    ])(
        "object idletime batch test_%p with isAtomic=%p",
        async (protocol, isAtomic) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = getRandomKey();
            const maxmemoryPolicyKey = "maxmemory-policy";
            const config = await client.configGet([maxmemoryPolicyKey]);
            const maxmemoryPolicy = config[maxmemoryPolicyKey];

            try {
                const batch = new Batch(isAtomic);
                batch.configSet({
                    // OBJECT IDLETIME requires a non-LFU maxmemory-policy
                    [maxmemoryPolicyKey]: "allkeys-random",
                });
                batch.set(key, "foo");
                batch.objectIdletime(key);

                const response = await client.exec(batch, true);
                expect(response).not.toBeNull();

                if (response != null) {
                    expect(response.length).toEqual(3);
                    // batch.configSet({[maxmemoryPolicyKey]: "allkeys-random"});
                    expect(response[0]).toEqual("OK");
                    // batch.set(key, "foo");
                    expect(response[1]).toEqual("OK");
                    // batch.objectIdletime(key);
                    expect(response[2]).toBeGreaterThanOrEqual(0);
                }
            } finally {
                expect(
                    await client.configSet({
                        [maxmemoryPolicyKey]: maxmemoryPolicy,
                    }),
                ).toEqual("OK");
            }

            client.close();
        },
    );

    it.each([
        [ProtocolVersion.RESP2, true],
        [ProtocolVersion.RESP2, false],
        [ProtocolVersion.RESP3, true],
        [ProtocolVersion.RESP3, false],
    ])(
        "object refcount batch test_%p with isAtomic=%p",
        async (protocol, isAtomic) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = getRandomKey();
            const batch = new Batch(isAtomic);
            batch.set(key, "foo");
            batch.objectRefcount(key);

            const response = await client.exec(batch, true);
            expect(response).not.toBeNull();

            if (response != null) {
                expect(response.length).toEqual(2);
                expect(response[0]).toEqual("OK"); // batch.set(key, "foo");
                expect(response[1]).toBeGreaterThanOrEqual(1); // batch.objectRefcount(key);
            }

            client.close();
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "lolwut test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            // Check for version string in LOLWUT output (dual string contains approach)
            const serverVersion = cluster.getVersion().trim();

            const result = await client.lolwut();
            expect(
                result.includes("ver") && result.includes(serverVersion),
            ).toBe(true);

            const result2 = await client.lolwut({ parameters: [] });
            expect(
                result2.includes("ver") && result2.includes(serverVersion),
            ).toBe(true);

            const result3 = await client.lolwut({ parameters: [50, 20] });
            expect(
                result3.includes("ver") && result3.includes(serverVersion),
            ).toBe(true);

            const result4 = await client.lolwut({ version: 6 });
            expect(
                result4.includes("ver") && result4.includes(serverVersion),
            ).toBe(true);

            const result5 = await client.lolwut({
                version: 5,
                parameters: [30, 4, 4],
            });
            expect(
                result5.includes("ver") && result5.includes(serverVersion),
            ).toBe(true);

            // Test LOLWUT version 9 (available in Valkey 9.0.0+)
            if (cluster.checkIfServerVersionLessThan("9.0.0") === false) {
                // Test with version 9 and 2 parameters (columns, rows)
                const result6 = await client.lolwut({
                    version: 9,
                    parameters: [30, 4],
                });
                expect(
                    result6.includes("ver") && result6.includes(serverVersion),
                ).toBe(true);

                // Test with version 9 and 4 parameters (columns, rows, real, imaginary)
                const result7 = await client.lolwut({
                    version: 9,
                    parameters: [40, 20, 1, 2],
                });
                expect(
                    result7.includes("ver") && result7.includes(serverVersion),
                ).toBe(true);
            }

            // batch tests
            for (const isAtomic of [true, false]) {
                const batch = new Batch(isAtomic);
                batch.lolwut();
                batch.lolwut({ version: 5 });
                batch.lolwut({ parameters: [1, 2] });
                batch.lolwut({ version: 6, parameters: [42] });
                const results = await client.exec(batch, true);

                if (results) {
                    for (const element of results) {
                        const elementStr = element?.toString() || "";
                        expect(
                            elementStr.includes("ver") &&
                                elementStr.includes(serverVersion),
                        ).toBe(true);
                    }
                } else {
                    throw new Error("Invalid LOLWUT batch test results.");
                }
            }

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "copy with DB test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("6.2.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const source = `{key}-${getRandomKey()}`;
            const destination = `{key}-${getRandomKey()}`;
            const value1 = getRandomKey();
            const value2 = getRandomKey();
            const index0 = 0;
            const index1 = 1;
            const index2 = 2;

            // neither key exists
            expect(
                await client.copy(source, destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(false);

            // source exists, destination does not
            expect(await client.set(source, value1)).toEqual("OK");
            expect(
                await client.copy(source, destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(true);
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value1);

            // new value for source key
            expect(await client.select(index0)).toEqual("OK");
            expect(await client.set(source, value2)).toEqual("OK");

            // no REPLACE, copying to existing key on DB 1, non-existing key on DB 2
            expect(
                await client.copy(Buffer.from(source), destination, {
                    destinationDB: index1,
                    replace: false,
                }),
            ).toEqual(false);
            expect(
                await client.copy(source, Buffer.from(destination), {
                    destinationDB: index2,
                    replace: false,
                }),
            ).toEqual(true);

            // new value only gets copied to DB 2
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value1);
            expect(await client.select(index2)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value2);

            // both exists, with REPLACE, when value isn't the same, source always get copied to
            // destination
            expect(await client.select(index0)).toEqual("OK");
            expect(
                await client.copy(
                    Buffer.from(source),
                    Buffer.from(destination),
                    {
                        destinationDB: index1,
                        replace: true,
                    },
                ),
            ).toEqual(true);
            expect(await client.select(index1)).toEqual("OK");
            expect(await client.get(destination)).toEqual(value2);

            // batch tests
            for (const isAtomic of [true, false]) {
                const batch = new Batch(isAtomic);
                batch.select(index1);
                batch.set(source, value1);
                batch.copy(source, destination, {
                    destinationDB: index1,
                    replace: true,
                });
                batch.get(destination);
                const results = await client.exec(batch, true);

                expect(results).toEqual(["OK", "OK", true, value1]);
            }

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "move test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + getRandomKey();
            const key2 = "{key}-2" + getRandomKey();
            const value = getRandomKey();

            expect(await client.select(0)).toEqual("OK");
            expect(await client.move(key1, 1)).toEqual(false);

            expect(await client.set(key1, value)).toEqual("OK");
            expect(await client.get(key1)).toEqual(value);
            expect(await client.move(Buffer.from(key1), 1)).toEqual(true);
            expect(await client.get(key1)).toEqual(null);
            expect(await client.select(1)).toEqual("OK");
            expect(await client.get(key1)).toEqual(value);

            await expect(client.move(key1, -1)).rejects.toThrow(RequestError);

            // batch tests
            for (const isAtomic of [true, false]) {
                expect(await client.flushall()).toEqual("OK");
                const batch = new Batch(isAtomic);
                batch.select(1);
                batch.move(key2, 0);
                batch.set(key2, value);
                batch.move(key2, 0);
                batch.select(0);
                batch.get(key2);
                const results = await client.exec(batch, true);

                expect(results).toEqual(["OK", false, "OK", true, "OK", value]);
            }

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function load function list function stats test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + getRandomKey().replaceAll("-", "");
                const funcName =
                    "myfunc1c" + getRandomKey().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(Buffer.from(code))).toEqual(
                    libName,
                );

                expect(
                    await client.fcall(
                        Buffer.from(funcName),
                        [],
                        [Buffer.from("one"), "two"],
                        { decoder: Decoder.Bytes },
                    ),
                ).toEqual(Buffer.from("one"));
                expect(
                    await client.fcallReadonly(
                        Buffer.from(funcName),
                        [],
                        ["one", Buffer.from("two")],
                        { decoder: Decoder.Bytes },
                    ),
                ).toEqual(Buffer.from("one"));

                let functionStats = await client.functionStats();

                for (const response of Object.values(functionStats)) {
                    checkFunctionStatsResponse(response, [], 1, 1);
                }

                let functionList = await client.functionList({
                    libNamePattern: Buffer.from(libName),
                    decoder: Decoder.Bytes,
                });
                let expectedDescription = new Map<string, GlideString | null>([
                    [funcName, null],
                ]);
                let expectedFlags = new Map<string, GlideString[]>([
                    [funcName, [Buffer.from("no-writes")]],
                ]);

                checkFunctionListResponse(
                    functionList,
                    Buffer.from(libName),
                    expectedDescription,
                    expectedFlags,
                );

                // re-load library without replace
                await expect(client.functionLoad(code)).rejects.toThrow(
                    `Library '${libName}' already exists`,
                );

                // re-load library with replace
                expect(
                    await client.functionLoad(code, {
                        replace: true,
                        decoder: Decoder.Bytes,
                    }),
                ).toEqual(Buffer.from(libName));

                // overwrite lib with new code
                const func2Name =
                    "myfunc2c" + getRandomKey().replaceAll("-", "");
                const newCode = generateLuaLibCode(
                    libName,
                    new Map([
                        [funcName, "return args[1]"],
                        [func2Name, "return #args"],
                    ]),
                    true,
                );
                expect(
                    await client.functionLoad(newCode, { replace: true }),
                ).toEqual(libName);

                functionList = await client.functionList({ withCode: true });
                expectedDescription = new Map<string, string | null>([
                    [funcName, null],
                    [func2Name, null],
                ]);
                expectedFlags = new Map<string, string[]>([
                    [funcName, ["no-writes"]],
                    [func2Name, ["no-writes"]],
                ]);

                checkFunctionListResponse(
                    functionList,
                    libName,
                    expectedDescription,
                    expectedFlags,
                    newCode,
                );

                functionStats = await client.functionStats({
                    decoder: Decoder.Bytes,
                });

                for (const response of Object.values(functionStats)) {
                    checkFunctionStatsResponse(response, [], 1, 2);
                }

                expect(
                    await client.fcall(func2Name, [], ["one", "two"]),
                ).toEqual(2);
                expect(
                    await client.fcallReadonly(func2Name, [], ["one", "two"]),
                ).toEqual(2);
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                const functionStats = await client.functionStats();

                for (const response of Object.values(functionStats)) {
                    checkFunctionStatsResponse(response, [], 0, 0);
                }

                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function flush test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + getRandomKey().replaceAll("-", "");
                const funcName =
                    "myfunc1c" + getRandomKey().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(code)).toEqual(libName);

                // Flush functions
                expect(await client.functionFlush(FlushMode.SYNC)).toEqual(
                    "OK",
                );
                expect(await client.functionFlush(FlushMode.ASYNC)).toEqual(
                    "OK",
                );

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                // Attempt to re-load library without overwriting to ensure FLUSH was effective
                expect(await client.functionLoad(code)).toEqual(libName);
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function delete test_%p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            try {
                const libName = "mylib1C" + getRandomKey().replaceAll("-", "");
                const funcName =
                    "myfunc1c" + getRandomKey().replaceAll("-", "");
                const code = generateLuaLibCode(
                    libName,
                    new Map([[funcName, "return args[1]"]]),
                    true,
                );
                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                expect(await client.functionLoad(code)).toEqual(libName);

                // Delete the function
                expect(await client.functionDelete(libName)).toEqual("OK");

                // verify function does not yet exist
                expect(await client.functionList()).toEqual([]);

                // deleting a non-existing library
                await expect(client.functionDelete(libName)).rejects.toThrow(
                    `Library not found`,
                );
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function kill RO func %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { requestTimeout: 10000 },
            );
            const client = await GlideClient.createClient(config);
            const testClient = await GlideClient.createClient(config);

            try {
                const libName = "function_kill_no_write";
                const funcName = "deadlock_no_write";
                const code = createLuaLibWithLongRunningFunction(
                    libName,
                    funcName,
                    6,
                    true,
                );
                expect(await client.functionFlush()).toEqual("OK");
                // nothing to kill
                await expect(client.functionKill()).rejects.toThrow(/notbusy/i);

                // load the lib
                expect(
                    await client.functionLoad(code, { replace: true }),
                ).toEqual(libName);

                try {
                    // call the function without await
                    const promise = testClient
                        .fcall(funcName, [], [])
                        .catch((e) =>
                            expect((e as Error).message).toContain(
                                "Script killed",
                            ),
                        );

                    let killed = false;
                    let pendingCallbacks = 0;
                    let callbacksCompleted = 0;

                    // Wait for the function to start executing
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Create a promise that resolves when 'killed' becomes true or all attempts fail
                    const killPromise = new Promise<boolean>((resolve) => {
                        const attemptKill = (remainingTime: number) => {
                            if (killed || remainingTime <= 0) {
                                resolve(killed);
                                return;
                            }

                            pendingCallbacks++;
                            client
                                .functionKill()
                                .then(() => {
                                    killed = true;
                                    callbacksCompleted++;
                                    resolve(true);
                                })
                                .catch(() => {
                                    callbacksCompleted++;
                                    // If not killed and still have time, try again
                                    setTimeout(
                                        () => attemptKill(remainingTime - 500),
                                        500,
                                    );
                                });
                        };

                        // Start the first attempt
                        attemptKill(4000);
                    });

                    // Wait for the kill to succeed or all attempts to fail
                    const killSucceeded = await killPromise;

                    // Wait for all pending callbacks to complete
                    while (callbacksCompleted < pendingCallbacks) {
                        await new Promise((resolve) =>
                            setTimeout(resolve, 100),
                        );
                    }

                    expect(killSucceeded).toBeTruthy();
                    await promise;
                } finally {
                    await waitForNotBusy(client);
                }
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                testClient.close();
                client.close();
            }
        },
        FUNCTION_TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "should handle connection timeout when client is blocked by long-running command (protocol: %p)",
        async (protocol) => {
            // Create a client configuration with a generous request timeout
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { requestTimeout: 20000 }, // Long timeout to allow debugging operations (sleep for 7 seconds)
            );

            // Initialize the primary client
            const client = await GlideClient.createClient(config);

            try {
                // Run a long-running DEBUG SLEEP command using the first client (client)
                const debugCommandPromise = client.customCommand(
                    ["DEBUG", "sleep", "7"], // Sleep for 7 seconds
                );

                // Function that tries to create a client with a short connection timeout (100ms)
                const failToCreateClient = async () => {
                    await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before retry
                    await expect(
                        GlideClient.createClient({
                            connectionBackoff: {
                                exponentBase: 2,
                                factor: 100,
                                numberOfRetries: 1,
                            },
                            advancedConfiguration: { connectionTimeout: 100 }, // 100ms connection timeout
                            ...config, // Include the rest of the config
                        }),
                    ).rejects.toThrowError(/timed out/i); // Ensure it throws a timeout error
                };

                // Function that verifies that a larger connection timeout allows connection
                const connectWithLargeTimeout = async () => {
                    await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before retry
                    const longerTimeoutClient = await GlideClient.createClient({
                        connectionBackoff: {
                            exponentBase: 2,
                            factor: 100,
                            numberOfRetries: 1,
                        },
                        advancedConfiguration: { connectionTimeout: 10000 }, // 10s connection timeout
                        ...config, // Include the rest of the config
                    });
                    expect(await client.set("x", "y")).toEqual("OK");
                    longerTimeoutClient.close(); // Close the client after successful connection
                };

                // Run both the long-running DEBUG SLEEP command and the client creation attempt in parallel
                await Promise.all([
                    debugCommandPromise, // Run the long-running command
                    failToCreateClient(), // Attempt to create the client with a short timeout
                ]);

                // Run all tasks: fail short timeout, succeed with large timeout, and run the debug command
                await Promise.all([
                    debugCommandPromise, // Run the long-running command
                    connectWithLargeTimeout(), // Attempt to create the client with a short timeout
                ]);
            } finally {
                // Clean up the test client and ensure everything is flushed and closed
                client.close();
            }
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function kill RW func %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { requestTimeout: 10000 },
            );
            const client = await GlideClient.createClient(config);
            const testClient = await GlideClient.createClient(config);

            try {
                const libName = "function_kill_write";
                const key = libName;
                const funcName = "deadlock_write";
                const code = createLuaLibWithLongRunningFunction(
                    libName,
                    funcName,
                    6,
                    false,
                );
                expect(await client.functionFlush()).toEqual("OK");
                // nothing to kill
                await expect(client.functionKill()).rejects.toThrow(/notbusy/i);

                // load the lib
                expect(
                    await client.functionLoad(code, { replace: true }),
                ).toEqual(libName);

                let promise = null;

                try {
                    // call the function without await
                    promise = testClient.fcall(funcName, [key], []);

                    let foundUnkillable = false;
                    let timeout = 4000;
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    while (timeout >= 0) {
                        try {
                            // valkey kills a function with 5 sec delay
                            // but this will always throw an error in the test
                            await client.functionKill();
                        } catch (err) {
                            // looking for an error with "unkillable" in the message
                            // at that point we can break the loop
                            if (
                                (err as Error).message
                                    .toLowerCase()
                                    .includes("unkillable")
                            ) {
                                foundUnkillable = true;
                                break;
                            }
                        }

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );
                        timeout -= 500;
                    }

                    expect(foundUnkillable).toBeTruthy();
                } finally {
                    // If function wasn't killed, and it didn't time out - it blocks the server and cause rest
                    // test to fail. Wait for the function to complete (we cannot kill it)
                    expect(await promise).toContain("Timed out");
                }
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                testClient.close();
                client.close();
            }
        },
        10000,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function dump function restore %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            const client = await GlideClient.createClient(config);
            expect(await client.functionFlush()).toEqual("OK");

            try {
                // dumping an empty lib
                expect(
                    (await client.functionDump()).byteLength,
                ).toBeGreaterThan(0);

                const name1 = "Foster";
                const name2 = "Dogster";
                // function $name1 returns first argument
                // function $name2 returns argument array len
                let code = generateLuaLibCode(
                    name1,
                    new Map([
                        [name1, "return args[1]"],
                        [name2, "return #args"],
                    ]),
                    false,
                );
                expect(await client.functionLoad(code)).toEqual(name1);

                const flist = await client.functionList({ withCode: true });
                const dump = await client.functionDump();

                // restore without cleaning the lib and/or overwrite option causes an error
                await expect(client.functionRestore(dump)).rejects.toThrow(
                    `Library ${name1} already exists`,
                );

                // APPEND policy also fails for the same reason (name collision)
                await expect(
                    client.functionRestore(dump, FunctionRestorePolicy.APPEND),
                ).rejects.toThrow(`Library ${name1} already exists`);

                // REPLACE policy succeeds
                expect(
                    await client.functionRestore(
                        dump,
                        FunctionRestorePolicy.REPLACE,
                    ),
                ).toEqual("OK");
                // but nothing changed - all code overwritten
                expect(await client.functionList({ withCode: true })).toEqual(
                    flist,
                );

                // create lib with another name, but with the same function names
                expect(await client.functionFlush(FlushMode.SYNC)).toEqual(
                    "OK",
                );
                code = generateLuaLibCode(
                    name2,
                    new Map([
                        [name1, "return args[1]"],
                        [name2, "return #args"],
                    ]),
                    false,
                );
                expect(await client.functionLoad(code)).toEqual(name2);

                // REPLACE policy now fails due to a name collision
                await expect(client.functionRestore(dump)).rejects.toThrow(
                    new RegExp(`Function ${name1}|${name2} already exists`),
                );

                // FLUSH policy succeeds, but deletes the second lib
                expect(
                    await client.functionRestore(
                        dump,
                        FunctionRestorePolicy.FLUSH,
                    ),
                ).toEqual("OK");
                expect(await client.functionList({ withCode: true })).toEqual(
                    flist,
                );

                // call restored functions
                expect(await client.fcall(name1, [], ["meow", "woem"])).toEqual(
                    "meow",
                );
                expect(await client.fcall(name2, [], ["meow", "woem"])).toEqual(
                    2,
                );
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "function dump function restore in transaction %p",
        async (protocol) => {
            if (cluster.checkIfServerVersionLessThan("7.0.0")) return;

            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
            );
            const client = await GlideClient.createClient(config);
            expect(await client.functionFlush()).toEqual("OK");

            try {
                const name1 = "Foster";
                const name2 = "Dogster";
                // function returns first argument
                const code = generateLuaLibCode(
                    name1,
                    new Map([[name2, "return args[1]"]]),
                    false,
                );
                expect(await client.functionLoad(code)).toEqual(name1);

                for (const isAtomic of [true, false]) {
                    // Verify functionDump
                    let batch = new Batch(isAtomic).functionDump();
                    const result = await client.exec(batch, true, {
                        decoder: Decoder.Bytes,
                    });
                    const data = result?.[0] as Buffer;

                    // Verify functionRestore
                    batch = new Batch(isAtomic)
                        .functionRestore(data, FunctionRestorePolicy.REPLACE)
                        .fcall(name2, [], ["meow"]);
                    expect(await client.exec(batch, true)).toEqual([
                        "OK",
                        "meow",
                    ]);
                }
            } finally {
                expect(await client.functionFlush()).toEqual("OK");
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "randomKey test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = getRandomKey();

            // setup: delete all keys in DB 0 and DB 1
            expect(await client.select(0)).toEqual("OK");
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");
            expect(await client.select(1)).toEqual("OK");
            expect(await client.flushdb(FlushMode.SYNC)).toEqual("OK");

            // no keys exist so randomKey returns null
            expect(await client.randomKey()).toBeNull();
            // set `key` in DB 1
            expect(await client.set(key, "foo")).toEqual("OK");
            // `key` should be the only key in the database
            expect(await client.randomKey()).toEqual(key);
            // test binary decoder
            expect(await client.randomKey({ decoder: Decoder.Bytes })).toEqual(
                Buffer.from(key),
            );

            // switch back to DB 0
            expect(await client.select(0)).toEqual("OK");
            // DB 0 should still have no keys, so randomKey should still return null
            expect(await client.randomKey()).toBeNull();

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "watch test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + getRandomKey();
            const key2 = "{key}-2" + getRandomKey();
            const key3 = "{key}-3" + getRandomKey();
            const key4 = "{key}-4" + getRandomKey();
            const setFoobarTransaction = new Batch(true);
            const setHelloTransaction = new Batch(true);

            // Returns null when a watched key is modified before it is executed in a transaction command.
            // Transaction commands are not performed.
            expect(await client.watch([key1, key2, key3])).toEqual("OK");
            expect(await client.set(key2, "hello")).toEqual("OK");
            setFoobarTransaction
                .set(key1, "foobar")
                .set(key2, "foobar")
                .set(key3, "foobar");
            let results = await client.exec(setFoobarTransaction, true);
            expect(results).toEqual(null);
            // sanity check
            expect(await client.get(key1)).toEqual(null);
            expect(await client.get(key2)).toEqual("hello");
            expect(await client.get(key3)).toEqual(null);

            // Transaction executes command successfully with a read command on the watch key before
            // transaction is executed.
            expect(await client.watch([key1, key2, key3])).toEqual("OK");
            expect(await client.get(key2)).toEqual("hello");
            results = await client.exec(setFoobarTransaction, true);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");
            expect(await client.get(key3)).toEqual("foobar");

            // Transaction executes command successfully with unmodified watched keys
            expect(await client.watch([key1, Buffer.from(key2), key3])).toEqual(
                "OK",
            );
            results = await client.exec(setFoobarTransaction, true);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");
            expect(await client.get(key3)).toEqual("foobar");

            // Transaction executes command successfully with a modified watched key but is not in the
            // transaction.
            expect(await client.watch([key4])).toEqual("OK");
            setHelloTransaction
                .set(key1, "hello")
                .set(key2, "hello")
                .set(key3, "hello");
            results = await client.exec(setHelloTransaction, true);
            expect(results).toEqual(["OK", "OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("hello");
            expect(await client.get(key2)).toEqual("hello");
            expect(await client.get(key3)).toEqual("hello");

            // WATCH can not have an empty String array parameter
            await expect(client.watch([])).rejects.toThrow(RequestError);

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "unwatch test_%p",
        async (protocol) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key1 = "{key}-1" + getRandomKey();
            const key2 = "{key}-2" + getRandomKey();

            const setFoobarTransaction = new Batch(true);

            // UNWATCH returns OK when there no watched keys
            expect(await client.unwatch()).toEqual("OK");

            // Transaction executes successfully after modifying a watched key then calling UNWATCH
            expect(await client.watch([key1, key2])).toEqual("OK");
            expect(await client.set(key2, "hello")).toEqual("OK");
            expect(await client.unwatch()).toEqual("OK");
            setFoobarTransaction.set(key1, "foobar").set(key2, "foobar");
            const results = await client.exec(setFoobarTransaction, true);
            expect(results).toEqual(["OK", "OK"]);
            // sanity check
            expect(await client.get(key1)).toEqual("foobar");
            expect(await client.get(key2)).toEqual("foobar");

            client.close();
        },
        TIMEOUT,
    );

    it.each([
        [ProtocolVersion.RESP2, true],
        [ProtocolVersion.RESP2, false],
        [ProtocolVersion.RESP3, true],
        [ProtocolVersion.RESP3, false],
    ])(
        "xinfo stream batch test_%p with isAtomic=%p",
        async (protocol, isAtomic) => {
            const client = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol),
            );

            const key = getRandomKey();

            const batch = new Batch(isAtomic);
            batch.xadd(key, [["field1", "value1"]], { id: "0-1" });
            batch.xinfoStream(key);
            batch.xinfoStream(key, true);
            const result = await client.exec(batch, true);
            expect(result).not.toBeNull();

            const versionLessThan7 =
                cluster.checkIfServerVersionLessThan("7.0.0");

            const expectedXinfoStreamResult = {
                length: 1,
                "radix-tree-keys": 1,
                "radix-tree-nodes": 2,
                "last-generated-id": "0-1",
                groups: 0,
                "first-entry": ["0-1", ["field1", "value1"]],
                "last-entry": ["0-1", ["field1", "value1"]],
                "max-deleted-entry-id": versionLessThan7 ? undefined : "0-0",
                "entries-added": versionLessThan7 ? undefined : 1,
                "recorded-first-entry-id": versionLessThan7 ? undefined : "0-1",
            };

            const expectedXinfoStreamFullResult = {
                length: 1,
                "radix-tree-keys": 1,
                "radix-tree-nodes": 2,
                "last-generated-id": "0-1",
                entries: [["0-1", ["field1", "value1"]]],
                groups: [],
                "max-deleted-entry-id": versionLessThan7 ? undefined : "0-0",
                "entries-added": versionLessThan7 ? undefined : 1,
                "recorded-first-entry-id": versionLessThan7 ? undefined : "0-1",
            };

            if (result != null) {
                expect(result[0]).toEqual("0-1"); // xadd
                const res1 = convertGlideRecordToRecord(
                    result[1] as GlideRecord<[GlideString, GlideString][]>,
                );
                const res2 = convertGlideRecordToRecord(
                    result[2] as GlideRecord<[GlideString, GlideString][]>,
                );
                expect(res1).toEqual(expectedXinfoStreamResult);
                expect(res2).toEqual(expectedXinfoStreamFullResult);
            }

            client.close();
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "script kill unkillable test_%p",
        async (protocol) => {
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { requestTimeout: 10000 },
            );
            const client1 = await GlideClient.createClient(config);
            const client2 = await GlideClient.createClient(config);

            // Verify that script kill raises an error when no script is running
            await expect(client1.scriptKill()).rejects.toThrow(
                "No scripts in execution right now",
            );

            // Create a long-running script
            const longScript = new Script(createLongRunningLuaScript(6, true));
            let promise = null;

            try {
                // call the script without await
                promise = client2.invokeScript(longScript, {
                    keys: ["{key}-" + getRandomKey()],
                });

                let foundUnkillable = false;
                let timeout = 4000;
                await new Promise((resolve) => setTimeout(resolve, 1000));

                // Wait until the script starts running
                while (timeout >= 0) {
                    try {
                        await client1.ping();
                    } catch (err) {
                        if (
                            (err as Error).message
                                .toLowerCase()
                                .includes("valkey is busy running a script")
                        ) {
                            break;
                        }

                        if (
                            timeout <= 2000 &&
                            (err as Error).message
                                .toLowerCase()
                                .includes("no scripts in execution right now")
                        ) {
                            promise = client2.invokeScript(longScript, {
                                keys: ["{key}-" + getRandomKey()],
                            });
                            await new Promise((resolve) =>
                                setTimeout(resolve, 1000),
                            );
                        }
                    }

                    timeout -= 500;
                }

                timeout = 4000;

                while (timeout >= 0) {
                    try {
                        // keep trying to kill until we get an "OK"
                        await client1.scriptKill();
                    } catch (err) {
                        // a RequestError may occur if the script is not yet running
                        // sleep and try again
                        if (
                            (err as Error).message
                                .toLowerCase()
                                .includes("unkillable")
                        ) {
                            foundUnkillable = true;
                            break;
                        }

                        if (
                            timeout <= 2000 &&
                            (err as Error).message
                                .toLowerCase()
                                .includes("no scripts in execution right now")
                        ) {
                            promise = client2.invokeScript(longScript, {
                                keys: ["{key}-" + getRandomKey()],
                            });
                            await new Promise((resolve) =>
                                setTimeout(resolve, 2000),
                            );
                        }
                    }

                    await new Promise((resolve) => setTimeout(resolve, 500));
                    timeout -= 500;
                }

                expect(foundUnkillable).toBeTruthy();
            } finally {
                // If script wasn't killed, and it didn't time out - it blocks the server and cause the
                // test to fail. Wait for the script to complete (we cannot kill it)
                longScript.release();
                expect(await promise).toContain("Timed out");
                client1.close();
                client2.close();
            }
        },
        TIMEOUT,
    );

    it.each([
        [ProtocolVersion.RESP2, 5],
        [ProtocolVersion.RESP2, 100],
        [ProtocolVersion.RESP2, 1500],
        [ProtocolVersion.RESP3, 5],
        [ProtocolVersion.RESP3, 100],
        [ProtocolVersion.RESP3, 1500],
    ])(
        "test inflight requests limit of %p with protocol %p",
        async (protocol, inflightRequestsLimit) => {
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                { inflightRequestsLimit },
            );
            const client = await GlideClient.createClient(config);

            try {
                const key1 = `{nonexistinglist}:1-${getRandomKey()}`;
                const tasks: Promise<[GlideString, GlideString] | null>[] = [];

                // Start inflightRequestsLimit blocking tasks
                for (let i = 0; i < inflightRequestsLimit; i++) {
                    tasks.push(client.blpop([key1], 0));
                }

                // This task should immediately fail due to reaching the limit
                await expect(client.blpop([key1], 0)).rejects.toThrow(
                    RequestError,
                );

                // Verify that all previous tasks are still pending
                const timeoutPromise = new Promise((resolve) =>
                    setTimeout(resolve, 100),
                );
                const allTasksStatus = await Promise.race([
                    Promise.any(
                        tasks.map((task) => task.then(() => "resolved")),
                    ),
                    timeoutPromise.then(() => "pending"),
                ]);
                expect(allTasksStatus).toBe("pending");
            } finally {
                client.close();
            }
        },
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "lazy connection establishes only on first command_%p",
        async (protocol) => {
            // Create a monitoring client (eagerly connected)
            const monitoringClient = await GlideClient.createClient(
                getClientConfigurationOption(cluster.getAddresses(), protocol, {
                    lazyConnect: false, // Explicit eager connection
                    requestTimeout: 3000,
                }),
            );

            try {
                // Get initial client count
                const getClientCount = async (): Promise<number> => {
                    const result = await monitoringClient.customCommand([
                        "CLIENT",
                        "LIST",
                    ]);
                    if (result === null) return 0;

                    const text = Buffer.isBuffer(result)
                        ? result.toString()
                        : String(result);
                    const lines = text.trim().split("\n");
                    return lines.filter((line) => line.trim().length > 0)
                        .length;
                };

                const clientsBeforeLazyInit = await getClientCount();

                // Create lazy client
                const lazyClient = await GlideClient.createClient(
                    getClientConfigurationOption(
                        cluster.getAddresses(),
                        protocol,
                        {
                            lazyConnect: true, // Lazy connection
                            requestTimeout: 3000,
                        },
                    ),
                );

                try {
                    // Verify no new connections were established
                    const clientsAfterLazyInit = await getClientCount();

                    expect(clientsAfterLazyInit).toEqual(clientsBeforeLazyInit);

                    // Send first command with lazy client
                    const pingResponse = await lazyClient.ping();
                    expect(pingResponse).toEqual("PONG");

                    // Check client count after first command
                    const clientsAfterFirstCommand = await getClientCount();

                    expect(clientsAfterFirstCommand).toEqual(
                        clientsBeforeLazyInit + 1,
                    );
                } finally {
                    await lazyClient.close();
                }
            } finally {
                await monitoringClient.close();
            }
        },
        TIMEOUT,
    );

    it.each([ProtocolVersion.RESP2, ProtocolVersion.RESP3])(
        "lazy connection with non-existent host_%p",
        async (protocol) => {
            const nonExistentHost = "non-existent-host-that-does-not-resolve";
            const baseConfig = {
                addresses: [{ host: nonExistentHost, port: 6379 }],
                protocol,
                requestTimeout: 1000,
            };

            // Test 1: Eager connection to non-existent host should fail immediately
            await expect(
                GlideClient.createClient({
                    ...baseConfig,
                    lazyConnect: false,
                }),
            ).rejects.toThrow(/connect|connection|resolve|network|host/i);

            // Test 2: Lazy connection to non-existent host should succeed in client creation
            const lazyClient = await GlideClient.createClient({
                ...baseConfig,
                lazyConnect: true,
            });

            try {
                // But command execution should fail with appropriate error
                await expect(lazyClient.ping()).rejects.toThrow(
                    /connect|connection|resolve|network|host/i,
                );
            } finally {
                lazyClient.close();
            }
        },
        TIMEOUT,
    );

    runBaseTests({
        init: async (protocol, configOverrides) => {
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                protocol,
                configOverrides,
            );
            client = await GlideClient.createClient(config);

            const configNew = getClientConfigurationOption(
                azCluster.getAddresses(),
                protocol,
                configOverrides,
            );

            testsFailed += 1;
            azClient = await GlideClient.createClient(configNew);
            client = await GlideClient.createClient(config);
            return { client, cluster, azClient, azCluster };
        },
        close: (testSucceeded: boolean) => {
            if (testSucceeded) {
                testsFailed -= 1;
            }
        },
        timeout: TIMEOUT,
    });

    it(
        "tcp nodelay configuration",
        async () => {
            const config = getClientConfigurationOption(
                cluster.getAddresses(),
                ProtocolVersion.RESP3,
            );

            // Test default (undefined - not set)
            const defaultClient = await GlideClient.createClient(config);
            expect(await defaultClient.ping()).toBe("PONG");
            expect(await defaultClient.set("key", "value")).toBe("OK");
            expect(await defaultClient.get("key")).toBe("value");
            defaultClient.close();

            // Test explicit true
            const clientTrue = await GlideClient.createClient({
                ...config,
                advancedConfiguration: { tcpNoDelay: true },
            });
            expect(await clientTrue.ping()).toBe("PONG");
            expect(await clientTrue.set("key2", "value2")).toBe("OK");
            expect(await clientTrue.get("key2")).toBe("value2");
            clientTrue.close();

            // Test explicit false
            const clientFalse = await GlideClient.createClient({
                ...config,
                advancedConfiguration: { tcpNoDelay: false },
            });
            expect(await clientFalse.ping()).toBe("PONG");
            expect(await clientFalse.set("key3", "value3")).toBe("OK");
            expect(await clientFalse.get("key3")).toBe("value3");
            clientFalse.close();
        },
        TIMEOUT,
    );
});
