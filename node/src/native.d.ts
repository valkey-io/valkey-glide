/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum Level {
    Debug = 3,
    Error = 0,
    Info = 2,
    Trace = 4,
    Warn = 1,
    Off = 5,
}
export const MAX_REQUEST_ARGS_LEN: number;
export const DEFAULT_REQUEST_TIMEOUT_IN_MILLISECONDS: number;
export const DEFAULT_CONNECTION_TIMEOUT_IN_MILLISECONDS: number;
export const DEFAULT_INFLIGHT_REQUESTS_LIMIT: number;
export declare function StartSocketConnection(): Promise<string>;
export declare function log(
    logLevel: Level,
    logIdentifier: string,
    message: string,
): void;
export declare function InitInternalLogger(
    level?: Level | undefined | null,
    fileName?: string | undefined | null,
): Level;
export declare function valueFromSplitPointer(
    highBits: number,
    lowBits: number,
    stringDecoder: boolean,
):
    | null
    | string
    | Uint8Array
    | number
    | {}
    | Boolean
    | BigInt
    | Set<any>
    | any[]
    | Buffer;
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedString(message: string): [number, number];
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedStringVec(
    message: Array<Uint8Array>,
): [number, number];
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedMap(
    map: Record<string, string>,
): [number, number];
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedArray(
    array: Array<string>,
): [number, number];
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedAttribute(
    message: string,
    attribute: Record<string, string>,
): [number, number];
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedBigint(bigInt: bigint): [number, number];
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedDouble(float: number): [number, number];
export declare function getStatistics(): object;
export declare class AsyncClient {
    static CreateConnection(connectionAddress: string): AsyncClient;
    get(key: string): Promise<string | Buffer | null>;
    set(key: string, value: string): Promise<string | Buffer | "OK" | null>;
}
/** A wrapper for a script object. As long as this object is alive, the script's code is saved in memory, and can be resent to the server. */
export declare class Script {
    /** Construct with the script's code. */
    constructor(code: string | Uint8Array);
    /** Returns the hash of the script. */
    getHash(): string;
}
/**
 * This struct is used to keep track of the cursor of a cluster scan.
 * We want to avoid passing the cursor between layers of the application,
 * So we keep the state in the container and only pass the id of the cursor.
 * The cursor is stored in the container and can be retrieved using the id.
 * The cursor is removed from the container when the object is deleted (dropped).
 * To create a cursor:
 * ```typescript
 * // For a new cursor
 * let cursor = new ClusterScanCursor();
 * // Using an existing id
 * let cursor = new ClusterScanCursor("cursor_id");
 * ```
 * To get the cursor id:
 * ```typescript
 * let cursorId = cursor.getCursor();
 * ```
 * To check if the scan is finished:
 * ```typescript
 * let isFinished = cursor.isFinished(); // true if the scan is finished
 * ```
 */
export declare class ClusterScanCursor {
    constructor(newCursor?: string | undefined | null);
    /** Returns the cursor id. */
    getCursor(): string;
    /** Returns true if the scan is finished. */
    isFinished(): boolean;
}
