name: Enhanced Dependabot Management

on:
  schedule:
    # Run every Monday at 10:00 AM UTC (after dependabot runs)
    - cron: '0 10 * * 1'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (no actual changes)'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  manage-dependabot-prs:
    runs-on: ubuntu-latest
    name: Manage Dependabot PRs with timing constraints
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm install @octokit/rest semver

      - name: Create PR management script
        run: |
          cat > dependabot-manager.js << 'EOF'
          const { Octokit } = require("@octokit/rest");
          const semver = require("semver");

          const octokit = new Octokit({
            auth: process.env.GITHUB_TOKEN,
          });

          const owner = process.env.GITHUB_REPOSITORY.split('/')[0];
          const repo = process.env.GITHUB_REPOSITORY.split('/')[1];
          const dryRun = process.env.DRY_RUN === 'true';

          async function main() {
            console.log(`Managing Dependabot PRs for ${owner}/${repo}`);
            console.log(`Dry run mode: ${dryRun}`);

            // Get all open PRs created by dependabot
            const { data: prs } = await octokit.rest.pulls.list({
              owner,
              repo,
              state: 'open',
            });

            const dependabotPrs = prs.filter(pr => 
              pr.user.login === 'dependabot[bot]' || 
              pr.head.ref.startsWith('dependabot/')
            );

            console.log(`Found ${dependabotPrs.length} dependabot PRs`);

            for (const pr of dependabotPrs) {
              await processPR(pr);
            }
          }

          async function processPR(pr) {
            console.log(`\nProcessing PR #${pr.number}: ${pr.title}`);
            
            // Parse the PR title to extract dependency info
            const titleMatch = pr.title.match(/^Bump (.+) from (.+) to (.+)$/);
            if (!titleMatch) {
              console.log(`  Skipping - unable to parse title: ${pr.title}`);
              return;
            }

            const [, depName, fromVersion, toVersion] = titleMatch;
            console.log(`  Dependency: ${depName} (${fromVersion} -> ${toVersion})`);

            // Determine update type
            const updateType = getUpdateType(fromVersion, toVersion);
            console.log(`  Update type: ${updateType}`);

            // Add changelog to PR if not already present
            await addChangelogToPR(pr, depName, fromVersion, toVersion);

            // Apply labels based on update type
            await applyLabels(pr, updateType);

            // Check if PR should be auto-approved based on timing
            const shouldAutoApprove = await shouldAutoApprovePR(pr, updateType);
            console.log(`  Should auto-approve: ${shouldAutoApprove}`);

            if (shouldAutoApprove && !dryRun) {
              await autoApprovePR(pr);
            }
          }

          function getUpdateType(fromVersion, toVersion) {
            try {
              const from = semver.coerce(fromVersion);
              const to = semver.coerce(toVersion);
              
              if (!from || !to) {
                return 'unknown';
              }

              if (semver.major(from) !== semver.major(to)) {
                return 'major';
              } else if (semver.minor(from) !== semver.minor(to)) {
                return 'minor';
              } else if (semver.patch(from) !== semver.patch(to)) {
                return 'patch';
              }
              
              return 'unknown';
            } catch (error) {
              console.log(`  Error determining update type: ${error.message}`);
              return 'unknown';
            }
          }

          async function shouldAutoApprovePR(pr, updateType) {
            const createdAt = new Date(pr.created_at);
            const now = new Date();
            const ageInDays = (now - createdAt) / (1000 * 60 * 60 * 24);

            console.log(`  PR age: ${ageInDays.toFixed(1)} days`);

            switch (updateType) {
              case 'patch':
                // Patch updates: immediately (but let's wait at least 1 hour for CI)
                return ageInDays >= 0.042; // ~1 hour
              case 'minor':
                // Minor updates: after 1 week
                return ageInDays >= 7;
              case 'major':
                // Major updates: after 3 weeks
                return ageInDays >= 21;
              default:
                // Unknown updates: treat as minor
                return ageInDays >= 7;
            }
          }

          async function addChangelogToPR(pr, depName, fromVersion, toVersion) {
            try {
              // Check if changelog is already added
              const { data: prData } = await octokit.rest.pulls.get({
                owner,
                repo,
                pull_number: pr.number,
              });

              const body = prData.body || '';
              if (body.includes('## Changelog') || body.includes('## Release Notes')) {
                console.log(`  Changelog already present`);
                return;
              }

              // Add basic changelog information
              const changelog = `## Changelog\n\nUpdated ${depName} from ${fromVersion} to ${toVersion}\n\nðŸ“‹ To view detailed changes, visit the package repository or release notes.`;
              
              const newBody = `${body}\n\n${changelog}`;
              
              if (!dryRun) {
                await octokit.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: pr.number,
                  body: newBody,
                });
                console.log(`  Added changelog to PR`);
              } else {
                console.log(`  Would add changelog to PR (dry run)`);
              }
            } catch (error) {
              console.log(`  Error adding changelog: ${error.message}`);
            }
          }

          async function applyLabels(pr, updateType) {
            try {
              const labels = ['dependencies'];
              
              // Add update type label
              if (updateType !== 'unknown') {
                labels.push(`dependency-${updateType}`);
              }

              if (!dryRun) {
                await octokit.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pr.number,
                  labels: labels,
                });
                console.log(`  Added labels: ${labels.join(', ')}`);
              } else {
                console.log(`  Would add labels: ${labels.join(', ')} (dry run)`);
              }
            } catch (error) {
              console.log(`  Error adding labels: ${error.message}`);
            }
          }

          async function autoApprovePR(pr) {
            try {
              // Check if PR has required checks passing
              const { data: checks } = await octokit.rest.checks.listForRef({
                owner,
                repo,
                ref: pr.head.sha,
              });

              const failedChecks = checks.check_runs.filter(check => 
                check.conclusion === 'failure' || check.conclusion === 'cancelled'
              );

              if (failedChecks.length > 0) {
                console.log(`  Cannot auto-approve - failed checks: ${failedChecks.map(c => c.name).join(', ')}`);
                return;
              }

              // Auto-approve the PR
              await octokit.rest.pulls.createReview({
                owner,
                repo,
                pull_number: pr.number,
                event: 'APPROVE',
                body: 'Auto-approved by enhanced dependabot workflow after timing constraints were met.',
              });

              console.log(`  Auto-approved PR #${pr.number}`);
            } catch (error) {
              console.log(`  Error auto-approving PR: ${error.message}`);
            }
          }

          main().catch(console.error);
          EOF

      - name: Run Dependabot PR management
        env:
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          node dependabot-manager.js

      - name: Summary
        run: |
          echo "## Dependabot Management Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Processed dependabot PRs with timing constraints" >> $GITHUB_STEP_SUMMARY
          echo "- Patch updates: Auto-approve after 1 hour" >> $GITHUB_STEP_SUMMARY
          echo "- Minor updates: Auto-approve after 1 week" >> $GITHUB_STEP_SUMMARY
          echo "- Major updates: Auto-approve after 3 weeks" >> $GITHUB_STEP_SUMMARY
          echo "- Dry run mode: ${{ inputs.dry_run || 'false' }}" >> $GITHUB_STEP_SUMMARY